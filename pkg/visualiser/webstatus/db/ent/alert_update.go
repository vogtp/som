// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"time"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
	"github.com/google/uuid"
	"github.com/vogtp/som/pkg/visualiser/webstatus/db/ent/alert"
	"github.com/vogtp/som/pkg/visualiser/webstatus/db/ent/counter"
	"github.com/vogtp/som/pkg/visualiser/webstatus/db/ent/failure"
	"github.com/vogtp/som/pkg/visualiser/webstatus/db/ent/file"
	"github.com/vogtp/som/pkg/visualiser/webstatus/db/ent/predicate"
	"github.com/vogtp/som/pkg/visualiser/webstatus/db/ent/status"
)

// AlertUpdate is the builder for updating Alert entities.
type AlertUpdate struct {
	config
	hooks    []Hook
	mutation *AlertMutation
}

// Where appends a list predicates to the AlertUpdate builder.
func (au *AlertUpdate) Where(ps ...predicate.Alert) *AlertUpdate {
	au.mutation.Where(ps...)
	return au
}

// SetUUID sets the "UUID" field.
func (au *AlertUpdate) SetUUID(u uuid.UUID) *AlertUpdate {
	au.mutation.SetUUID(u)
	return au
}

// SetIncidentID sets the "IncidentID" field.
func (au *AlertUpdate) SetIncidentID(u uuid.UUID) *AlertUpdate {
	au.mutation.SetIncidentID(u)
	return au
}

// SetNillableIncidentID sets the "IncidentID" field if the given value is not nil.
func (au *AlertUpdate) SetNillableIncidentID(u *uuid.UUID) *AlertUpdate {
	if u != nil {
		au.SetIncidentID(*u)
	}
	return au
}

// ClearIncidentID clears the value of the "IncidentID" field.
func (au *AlertUpdate) ClearIncidentID() *AlertUpdate {
	au.mutation.ClearIncidentID()
	return au
}

// SetName sets the "Name" field.
func (au *AlertUpdate) SetName(s string) *AlertUpdate {
	au.mutation.SetName(s)
	return au
}

// SetTime sets the "Time" field.
func (au *AlertUpdate) SetTime(t time.Time) *AlertUpdate {
	au.mutation.SetTime(t)
	return au
}

// SetIntLevel sets the "IntLevel" field.
func (au *AlertUpdate) SetIntLevel(i int) *AlertUpdate {
	au.mutation.ResetIntLevel()
	au.mutation.SetIntLevel(i)
	return au
}

// AddIntLevel adds i to the "IntLevel" field.
func (au *AlertUpdate) AddIntLevel(i int) *AlertUpdate {
	au.mutation.AddIntLevel(i)
	return au
}

// SetUsername sets the "Username" field.
func (au *AlertUpdate) SetUsername(s string) *AlertUpdate {
	au.mutation.SetUsername(s)
	return au
}

// SetRegion sets the "Region" field.
func (au *AlertUpdate) SetRegion(s string) *AlertUpdate {
	au.mutation.SetRegion(s)
	return au
}

// SetProbeOS sets the "ProbeOS" field.
func (au *AlertUpdate) SetProbeOS(s string) *AlertUpdate {
	au.mutation.SetProbeOS(s)
	return au
}

// SetProbeHost sets the "ProbeHost" field.
func (au *AlertUpdate) SetProbeHost(s string) *AlertUpdate {
	au.mutation.SetProbeHost(s)
	return au
}

// SetError sets the "Error" field.
func (au *AlertUpdate) SetError(s string) *AlertUpdate {
	au.mutation.SetError(s)
	return au
}

// SetNillableError sets the "Error" field if the given value is not nil.
func (au *AlertUpdate) SetNillableError(s *string) *AlertUpdate {
	if s != nil {
		au.SetError(*s)
	}
	return au
}

// ClearError clears the value of the "Error" field.
func (au *AlertUpdate) ClearError() *AlertUpdate {
	au.mutation.ClearError()
	return au
}

// AddCounterIDs adds the "Counters" edge to the Counter entity by IDs.
func (au *AlertUpdate) AddCounterIDs(ids ...int) *AlertUpdate {
	au.mutation.AddCounterIDs(ids...)
	return au
}

// AddCounters adds the "Counters" edges to the Counter entity.
func (au *AlertUpdate) AddCounters(c ...*Counter) *AlertUpdate {
	ids := make([]int, len(c))
	for i := range c {
		ids[i] = c[i].ID
	}
	return au.AddCounterIDs(ids...)
}

// AddStatiIDs adds the "Stati" edge to the Status entity by IDs.
func (au *AlertUpdate) AddStatiIDs(ids ...int) *AlertUpdate {
	au.mutation.AddStatiIDs(ids...)
	return au
}

// AddStati adds the "Stati" edges to the Status entity.
func (au *AlertUpdate) AddStati(s ...*Status) *AlertUpdate {
	ids := make([]int, len(s))
	for i := range s {
		ids[i] = s[i].ID
	}
	return au.AddStatiIDs(ids...)
}

// AddFailureIDs adds the "Failures" edge to the Failure entity by IDs.
func (au *AlertUpdate) AddFailureIDs(ids ...int) *AlertUpdate {
	au.mutation.AddFailureIDs(ids...)
	return au
}

// AddFailures adds the "Failures" edges to the Failure entity.
func (au *AlertUpdate) AddFailures(f ...*Failure) *AlertUpdate {
	ids := make([]int, len(f))
	for i := range f {
		ids[i] = f[i].ID
	}
	return au.AddFailureIDs(ids...)
}

// AddFileIDs adds the "Files" edge to the File entity by IDs.
func (au *AlertUpdate) AddFileIDs(ids ...int) *AlertUpdate {
	au.mutation.AddFileIDs(ids...)
	return au
}

// AddFiles adds the "Files" edges to the File entity.
func (au *AlertUpdate) AddFiles(f ...*File) *AlertUpdate {
	ids := make([]int, len(f))
	for i := range f {
		ids[i] = f[i].ID
	}
	return au.AddFileIDs(ids...)
}

// Mutation returns the AlertMutation object of the builder.
func (au *AlertUpdate) Mutation() *AlertMutation {
	return au.mutation
}

// ClearCounters clears all "Counters" edges to the Counter entity.
func (au *AlertUpdate) ClearCounters() *AlertUpdate {
	au.mutation.ClearCounters()
	return au
}

// RemoveCounterIDs removes the "Counters" edge to Counter entities by IDs.
func (au *AlertUpdate) RemoveCounterIDs(ids ...int) *AlertUpdate {
	au.mutation.RemoveCounterIDs(ids...)
	return au
}

// RemoveCounters removes "Counters" edges to Counter entities.
func (au *AlertUpdate) RemoveCounters(c ...*Counter) *AlertUpdate {
	ids := make([]int, len(c))
	for i := range c {
		ids[i] = c[i].ID
	}
	return au.RemoveCounterIDs(ids...)
}

// ClearStati clears all "Stati" edges to the Status entity.
func (au *AlertUpdate) ClearStati() *AlertUpdate {
	au.mutation.ClearStati()
	return au
}

// RemoveStatiIDs removes the "Stati" edge to Status entities by IDs.
func (au *AlertUpdate) RemoveStatiIDs(ids ...int) *AlertUpdate {
	au.mutation.RemoveStatiIDs(ids...)
	return au
}

// RemoveStati removes "Stati" edges to Status entities.
func (au *AlertUpdate) RemoveStati(s ...*Status) *AlertUpdate {
	ids := make([]int, len(s))
	for i := range s {
		ids[i] = s[i].ID
	}
	return au.RemoveStatiIDs(ids...)
}

// ClearFailures clears all "Failures" edges to the Failure entity.
func (au *AlertUpdate) ClearFailures() *AlertUpdate {
	au.mutation.ClearFailures()
	return au
}

// RemoveFailureIDs removes the "Failures" edge to Failure entities by IDs.
func (au *AlertUpdate) RemoveFailureIDs(ids ...int) *AlertUpdate {
	au.mutation.RemoveFailureIDs(ids...)
	return au
}

// RemoveFailures removes "Failures" edges to Failure entities.
func (au *AlertUpdate) RemoveFailures(f ...*Failure) *AlertUpdate {
	ids := make([]int, len(f))
	for i := range f {
		ids[i] = f[i].ID
	}
	return au.RemoveFailureIDs(ids...)
}

// ClearFiles clears all "Files" edges to the File entity.
func (au *AlertUpdate) ClearFiles() *AlertUpdate {
	au.mutation.ClearFiles()
	return au
}

// RemoveFileIDs removes the "Files" edge to File entities by IDs.
func (au *AlertUpdate) RemoveFileIDs(ids ...int) *AlertUpdate {
	au.mutation.RemoveFileIDs(ids...)
	return au
}

// RemoveFiles removes "Files" edges to File entities.
func (au *AlertUpdate) RemoveFiles(f ...*File) *AlertUpdate {
	ids := make([]int, len(f))
	for i := range f {
		ids[i] = f[i].ID
	}
	return au.RemoveFileIDs(ids...)
}

// Save executes the query and returns the number of nodes affected by the update operation.
func (au *AlertUpdate) Save(ctx context.Context) (int, error) {
	return withHooks(ctx, au.sqlSave, au.mutation, au.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (au *AlertUpdate) SaveX(ctx context.Context) int {
	affected, err := au.Save(ctx)
	if err != nil {
		panic(err)
	}
	return affected
}

// Exec executes the query.
func (au *AlertUpdate) Exec(ctx context.Context) error {
	_, err := au.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (au *AlertUpdate) ExecX(ctx context.Context) {
	if err := au.Exec(ctx); err != nil {
		panic(err)
	}
}

func (au *AlertUpdate) sqlSave(ctx context.Context) (n int, err error) {
	_spec := sqlgraph.NewUpdateSpec(alert.Table, alert.Columns, sqlgraph.NewFieldSpec(alert.FieldID, field.TypeInt))
	if ps := au.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := au.mutation.UUID(); ok {
		_spec.SetField(alert.FieldUUID, field.TypeUUID, value)
	}
	if value, ok := au.mutation.IncidentID(); ok {
		_spec.SetField(alert.FieldIncidentID, field.TypeUUID, value)
	}
	if au.mutation.IncidentIDCleared() {
		_spec.ClearField(alert.FieldIncidentID, field.TypeUUID)
	}
	if value, ok := au.mutation.Name(); ok {
		_spec.SetField(alert.FieldName, field.TypeString, value)
	}
	if value, ok := au.mutation.Time(); ok {
		_spec.SetField(alert.FieldTime, field.TypeTime, value)
	}
	if value, ok := au.mutation.IntLevel(); ok {
		_spec.SetField(alert.FieldIntLevel, field.TypeInt, value)
	}
	if value, ok := au.mutation.AddedIntLevel(); ok {
		_spec.AddField(alert.FieldIntLevel, field.TypeInt, value)
	}
	if value, ok := au.mutation.Username(); ok {
		_spec.SetField(alert.FieldUsername, field.TypeString, value)
	}
	if value, ok := au.mutation.Region(); ok {
		_spec.SetField(alert.FieldRegion, field.TypeString, value)
	}
	if value, ok := au.mutation.ProbeOS(); ok {
		_spec.SetField(alert.FieldProbeOS, field.TypeString, value)
	}
	if value, ok := au.mutation.ProbeHost(); ok {
		_spec.SetField(alert.FieldProbeHost, field.TypeString, value)
	}
	if value, ok := au.mutation.Error(); ok {
		_spec.SetField(alert.FieldError, field.TypeString, value)
	}
	if au.mutation.ErrorCleared() {
		_spec.ClearField(alert.FieldError, field.TypeString)
	}
	if au.mutation.CountersCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   alert.CountersTable,
			Columns: []string{alert.CountersColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(counter.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := au.mutation.RemovedCountersIDs(); len(nodes) > 0 && !au.mutation.CountersCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   alert.CountersTable,
			Columns: []string{alert.CountersColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(counter.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := au.mutation.CountersIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   alert.CountersTable,
			Columns: []string{alert.CountersColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(counter.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if au.mutation.StatiCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   alert.StatiTable,
			Columns: []string{alert.StatiColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(status.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := au.mutation.RemovedStatiIDs(); len(nodes) > 0 && !au.mutation.StatiCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   alert.StatiTable,
			Columns: []string{alert.StatiColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(status.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := au.mutation.StatiIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   alert.StatiTable,
			Columns: []string{alert.StatiColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(status.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if au.mutation.FailuresCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   alert.FailuresTable,
			Columns: []string{alert.FailuresColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(failure.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := au.mutation.RemovedFailuresIDs(); len(nodes) > 0 && !au.mutation.FailuresCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   alert.FailuresTable,
			Columns: []string{alert.FailuresColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(failure.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := au.mutation.FailuresIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   alert.FailuresTable,
			Columns: []string{alert.FailuresColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(failure.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if au.mutation.FilesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   alert.FilesTable,
			Columns: []string{alert.FilesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(file.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := au.mutation.RemovedFilesIDs(); len(nodes) > 0 && !au.mutation.FilesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   alert.FilesTable,
			Columns: []string{alert.FilesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(file.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := au.mutation.FilesIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   alert.FilesTable,
			Columns: []string{alert.FilesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(file.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if n, err = sqlgraph.UpdateNodes(ctx, au.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{alert.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return 0, err
	}
	au.mutation.done = true
	return n, nil
}

// AlertUpdateOne is the builder for updating a single Alert entity.
type AlertUpdateOne struct {
	config
	fields   []string
	hooks    []Hook
	mutation *AlertMutation
}

// SetUUID sets the "UUID" field.
func (auo *AlertUpdateOne) SetUUID(u uuid.UUID) *AlertUpdateOne {
	auo.mutation.SetUUID(u)
	return auo
}

// SetIncidentID sets the "IncidentID" field.
func (auo *AlertUpdateOne) SetIncidentID(u uuid.UUID) *AlertUpdateOne {
	auo.mutation.SetIncidentID(u)
	return auo
}

// SetNillableIncidentID sets the "IncidentID" field if the given value is not nil.
func (auo *AlertUpdateOne) SetNillableIncidentID(u *uuid.UUID) *AlertUpdateOne {
	if u != nil {
		auo.SetIncidentID(*u)
	}
	return auo
}

// ClearIncidentID clears the value of the "IncidentID" field.
func (auo *AlertUpdateOne) ClearIncidentID() *AlertUpdateOne {
	auo.mutation.ClearIncidentID()
	return auo
}

// SetName sets the "Name" field.
func (auo *AlertUpdateOne) SetName(s string) *AlertUpdateOne {
	auo.mutation.SetName(s)
	return auo
}

// SetTime sets the "Time" field.
func (auo *AlertUpdateOne) SetTime(t time.Time) *AlertUpdateOne {
	auo.mutation.SetTime(t)
	return auo
}

// SetIntLevel sets the "IntLevel" field.
func (auo *AlertUpdateOne) SetIntLevel(i int) *AlertUpdateOne {
	auo.mutation.ResetIntLevel()
	auo.mutation.SetIntLevel(i)
	return auo
}

// AddIntLevel adds i to the "IntLevel" field.
func (auo *AlertUpdateOne) AddIntLevel(i int) *AlertUpdateOne {
	auo.mutation.AddIntLevel(i)
	return auo
}

// SetUsername sets the "Username" field.
func (auo *AlertUpdateOne) SetUsername(s string) *AlertUpdateOne {
	auo.mutation.SetUsername(s)
	return auo
}

// SetRegion sets the "Region" field.
func (auo *AlertUpdateOne) SetRegion(s string) *AlertUpdateOne {
	auo.mutation.SetRegion(s)
	return auo
}

// SetProbeOS sets the "ProbeOS" field.
func (auo *AlertUpdateOne) SetProbeOS(s string) *AlertUpdateOne {
	auo.mutation.SetProbeOS(s)
	return auo
}

// SetProbeHost sets the "ProbeHost" field.
func (auo *AlertUpdateOne) SetProbeHost(s string) *AlertUpdateOne {
	auo.mutation.SetProbeHost(s)
	return auo
}

// SetError sets the "Error" field.
func (auo *AlertUpdateOne) SetError(s string) *AlertUpdateOne {
	auo.mutation.SetError(s)
	return auo
}

// SetNillableError sets the "Error" field if the given value is not nil.
func (auo *AlertUpdateOne) SetNillableError(s *string) *AlertUpdateOne {
	if s != nil {
		auo.SetError(*s)
	}
	return auo
}

// ClearError clears the value of the "Error" field.
func (auo *AlertUpdateOne) ClearError() *AlertUpdateOne {
	auo.mutation.ClearError()
	return auo
}

// AddCounterIDs adds the "Counters" edge to the Counter entity by IDs.
func (auo *AlertUpdateOne) AddCounterIDs(ids ...int) *AlertUpdateOne {
	auo.mutation.AddCounterIDs(ids...)
	return auo
}

// AddCounters adds the "Counters" edges to the Counter entity.
func (auo *AlertUpdateOne) AddCounters(c ...*Counter) *AlertUpdateOne {
	ids := make([]int, len(c))
	for i := range c {
		ids[i] = c[i].ID
	}
	return auo.AddCounterIDs(ids...)
}

// AddStatiIDs adds the "Stati" edge to the Status entity by IDs.
func (auo *AlertUpdateOne) AddStatiIDs(ids ...int) *AlertUpdateOne {
	auo.mutation.AddStatiIDs(ids...)
	return auo
}

// AddStati adds the "Stati" edges to the Status entity.
func (auo *AlertUpdateOne) AddStati(s ...*Status) *AlertUpdateOne {
	ids := make([]int, len(s))
	for i := range s {
		ids[i] = s[i].ID
	}
	return auo.AddStatiIDs(ids...)
}

// AddFailureIDs adds the "Failures" edge to the Failure entity by IDs.
func (auo *AlertUpdateOne) AddFailureIDs(ids ...int) *AlertUpdateOne {
	auo.mutation.AddFailureIDs(ids...)
	return auo
}

// AddFailures adds the "Failures" edges to the Failure entity.
func (auo *AlertUpdateOne) AddFailures(f ...*Failure) *AlertUpdateOne {
	ids := make([]int, len(f))
	for i := range f {
		ids[i] = f[i].ID
	}
	return auo.AddFailureIDs(ids...)
}

// AddFileIDs adds the "Files" edge to the File entity by IDs.
func (auo *AlertUpdateOne) AddFileIDs(ids ...int) *AlertUpdateOne {
	auo.mutation.AddFileIDs(ids...)
	return auo
}

// AddFiles adds the "Files" edges to the File entity.
func (auo *AlertUpdateOne) AddFiles(f ...*File) *AlertUpdateOne {
	ids := make([]int, len(f))
	for i := range f {
		ids[i] = f[i].ID
	}
	return auo.AddFileIDs(ids...)
}

// Mutation returns the AlertMutation object of the builder.
func (auo *AlertUpdateOne) Mutation() *AlertMutation {
	return auo.mutation
}

// ClearCounters clears all "Counters" edges to the Counter entity.
func (auo *AlertUpdateOne) ClearCounters() *AlertUpdateOne {
	auo.mutation.ClearCounters()
	return auo
}

// RemoveCounterIDs removes the "Counters" edge to Counter entities by IDs.
func (auo *AlertUpdateOne) RemoveCounterIDs(ids ...int) *AlertUpdateOne {
	auo.mutation.RemoveCounterIDs(ids...)
	return auo
}

// RemoveCounters removes "Counters" edges to Counter entities.
func (auo *AlertUpdateOne) RemoveCounters(c ...*Counter) *AlertUpdateOne {
	ids := make([]int, len(c))
	for i := range c {
		ids[i] = c[i].ID
	}
	return auo.RemoveCounterIDs(ids...)
}

// ClearStati clears all "Stati" edges to the Status entity.
func (auo *AlertUpdateOne) ClearStati() *AlertUpdateOne {
	auo.mutation.ClearStati()
	return auo
}

// RemoveStatiIDs removes the "Stati" edge to Status entities by IDs.
func (auo *AlertUpdateOne) RemoveStatiIDs(ids ...int) *AlertUpdateOne {
	auo.mutation.RemoveStatiIDs(ids...)
	return auo
}

// RemoveStati removes "Stati" edges to Status entities.
func (auo *AlertUpdateOne) RemoveStati(s ...*Status) *AlertUpdateOne {
	ids := make([]int, len(s))
	for i := range s {
		ids[i] = s[i].ID
	}
	return auo.RemoveStatiIDs(ids...)
}

// ClearFailures clears all "Failures" edges to the Failure entity.
func (auo *AlertUpdateOne) ClearFailures() *AlertUpdateOne {
	auo.mutation.ClearFailures()
	return auo
}

// RemoveFailureIDs removes the "Failures" edge to Failure entities by IDs.
func (auo *AlertUpdateOne) RemoveFailureIDs(ids ...int) *AlertUpdateOne {
	auo.mutation.RemoveFailureIDs(ids...)
	return auo
}

// RemoveFailures removes "Failures" edges to Failure entities.
func (auo *AlertUpdateOne) RemoveFailures(f ...*Failure) *AlertUpdateOne {
	ids := make([]int, len(f))
	for i := range f {
		ids[i] = f[i].ID
	}
	return auo.RemoveFailureIDs(ids...)
}

// ClearFiles clears all "Files" edges to the File entity.
func (auo *AlertUpdateOne) ClearFiles() *AlertUpdateOne {
	auo.mutation.ClearFiles()
	return auo
}

// RemoveFileIDs removes the "Files" edge to File entities by IDs.
func (auo *AlertUpdateOne) RemoveFileIDs(ids ...int) *AlertUpdateOne {
	auo.mutation.RemoveFileIDs(ids...)
	return auo
}

// RemoveFiles removes "Files" edges to File entities.
func (auo *AlertUpdateOne) RemoveFiles(f ...*File) *AlertUpdateOne {
	ids := make([]int, len(f))
	for i := range f {
		ids[i] = f[i].ID
	}
	return auo.RemoveFileIDs(ids...)
}

// Where appends a list predicates to the AlertUpdate builder.
func (auo *AlertUpdateOne) Where(ps ...predicate.Alert) *AlertUpdateOne {
	auo.mutation.Where(ps...)
	return auo
}

// Select allows selecting one or more fields (columns) of the returned entity.
// The default is selecting all fields defined in the entity schema.
func (auo *AlertUpdateOne) Select(field string, fields ...string) *AlertUpdateOne {
	auo.fields = append([]string{field}, fields...)
	return auo
}

// Save executes the query and returns the updated Alert entity.
func (auo *AlertUpdateOne) Save(ctx context.Context) (*Alert, error) {
	return withHooks(ctx, auo.sqlSave, auo.mutation, auo.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (auo *AlertUpdateOne) SaveX(ctx context.Context) *Alert {
	node, err := auo.Save(ctx)
	if err != nil {
		panic(err)
	}
	return node
}

// Exec executes the query on the entity.
func (auo *AlertUpdateOne) Exec(ctx context.Context) error {
	_, err := auo.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (auo *AlertUpdateOne) ExecX(ctx context.Context) {
	if err := auo.Exec(ctx); err != nil {
		panic(err)
	}
}

func (auo *AlertUpdateOne) sqlSave(ctx context.Context) (_node *Alert, err error) {
	_spec := sqlgraph.NewUpdateSpec(alert.Table, alert.Columns, sqlgraph.NewFieldSpec(alert.FieldID, field.TypeInt))
	id, ok := auo.mutation.ID()
	if !ok {
		return nil, &ValidationError{Name: "id", err: errors.New(`ent: missing "Alert.id" for update`)}
	}
	_spec.Node.ID.Value = id
	if fields := auo.fields; len(fields) > 0 {
		_spec.Node.Columns = make([]string, 0, len(fields))
		_spec.Node.Columns = append(_spec.Node.Columns, alert.FieldID)
		for _, f := range fields {
			if !alert.ValidColumn(f) {
				return nil, &ValidationError{Name: f, err: fmt.Errorf("ent: invalid field %q for query", f)}
			}
			if f != alert.FieldID {
				_spec.Node.Columns = append(_spec.Node.Columns, f)
			}
		}
	}
	if ps := auo.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := auo.mutation.UUID(); ok {
		_spec.SetField(alert.FieldUUID, field.TypeUUID, value)
	}
	if value, ok := auo.mutation.IncidentID(); ok {
		_spec.SetField(alert.FieldIncidentID, field.TypeUUID, value)
	}
	if auo.mutation.IncidentIDCleared() {
		_spec.ClearField(alert.FieldIncidentID, field.TypeUUID)
	}
	if value, ok := auo.mutation.Name(); ok {
		_spec.SetField(alert.FieldName, field.TypeString, value)
	}
	if value, ok := auo.mutation.Time(); ok {
		_spec.SetField(alert.FieldTime, field.TypeTime, value)
	}
	if value, ok := auo.mutation.IntLevel(); ok {
		_spec.SetField(alert.FieldIntLevel, field.TypeInt, value)
	}
	if value, ok := auo.mutation.AddedIntLevel(); ok {
		_spec.AddField(alert.FieldIntLevel, field.TypeInt, value)
	}
	if value, ok := auo.mutation.Username(); ok {
		_spec.SetField(alert.FieldUsername, field.TypeString, value)
	}
	if value, ok := auo.mutation.Region(); ok {
		_spec.SetField(alert.FieldRegion, field.TypeString, value)
	}
	if value, ok := auo.mutation.ProbeOS(); ok {
		_spec.SetField(alert.FieldProbeOS, field.TypeString, value)
	}
	if value, ok := auo.mutation.ProbeHost(); ok {
		_spec.SetField(alert.FieldProbeHost, field.TypeString, value)
	}
	if value, ok := auo.mutation.Error(); ok {
		_spec.SetField(alert.FieldError, field.TypeString, value)
	}
	if auo.mutation.ErrorCleared() {
		_spec.ClearField(alert.FieldError, field.TypeString)
	}
	if auo.mutation.CountersCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   alert.CountersTable,
			Columns: []string{alert.CountersColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(counter.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := auo.mutation.RemovedCountersIDs(); len(nodes) > 0 && !auo.mutation.CountersCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   alert.CountersTable,
			Columns: []string{alert.CountersColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(counter.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := auo.mutation.CountersIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   alert.CountersTable,
			Columns: []string{alert.CountersColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(counter.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if auo.mutation.StatiCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   alert.StatiTable,
			Columns: []string{alert.StatiColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(status.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := auo.mutation.RemovedStatiIDs(); len(nodes) > 0 && !auo.mutation.StatiCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   alert.StatiTable,
			Columns: []string{alert.StatiColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(status.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := auo.mutation.StatiIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   alert.StatiTable,
			Columns: []string{alert.StatiColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(status.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if auo.mutation.FailuresCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   alert.FailuresTable,
			Columns: []string{alert.FailuresColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(failure.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := auo.mutation.RemovedFailuresIDs(); len(nodes) > 0 && !auo.mutation.FailuresCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   alert.FailuresTable,
			Columns: []string{alert.FailuresColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(failure.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := auo.mutation.FailuresIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   alert.FailuresTable,
			Columns: []string{alert.FailuresColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(failure.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if auo.mutation.FilesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   alert.FilesTable,
			Columns: []string{alert.FilesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(file.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := auo.mutation.RemovedFilesIDs(); len(nodes) > 0 && !auo.mutation.FilesCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   alert.FilesTable,
			Columns: []string{alert.FilesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(file.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := auo.mutation.FilesIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   alert.FilesTable,
			Columns: []string{alert.FilesColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(file.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	_node = &Alert{config: auo.config}
	_spec.Assign = _node.assignValues
	_spec.ScanValues = _node.scanValues
	if err = sqlgraph.UpdateNode(ctx, auo.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{alert.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return nil, err
	}
	auo.mutation.done = true
	return _node, nil
}
