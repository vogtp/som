// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"

	"entgo.io/contrib/entgql"
	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/errcode"
	"github.com/vektah/gqlparser/v2/gqlerror"
	"github.com/vogtp/som/pkg/visualiser/webstatus/db/ent/alert"
	"github.com/vogtp/som/pkg/visualiser/webstatus/db/ent/counter"
	"github.com/vogtp/som/pkg/visualiser/webstatus/db/ent/failure"
	"github.com/vogtp/som/pkg/visualiser/webstatus/db/ent/file"
	"github.com/vogtp/som/pkg/visualiser/webstatus/db/ent/incident"
	"github.com/vogtp/som/pkg/visualiser/webstatus/db/ent/status"
)

// Common entgql types.
type (
	Cursor         = entgql.Cursor[int]
	PageInfo       = entgql.PageInfo[int]
	OrderDirection = entgql.OrderDirection
)

func orderFunc(o OrderDirection, field string) func(*sql.Selector) {
	if o == entgql.OrderDirectionDesc {
		return Desc(field)
	}
	return Asc(field)
}

const errInvalidPagination = "INVALID_PAGINATION"

func validateFirstLast(first, last *int) (err *gqlerror.Error) {
	switch {
	case first != nil && last != nil:
		err = &gqlerror.Error{
			Message: "Passing both `first` and `last` to paginate a connection is not supported.",
		}
	case first != nil && *first < 0:
		err = &gqlerror.Error{
			Message: "`first` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	case last != nil && *last < 0:
		err = &gqlerror.Error{
			Message: "`last` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	}
	return err
}

func collectedField(ctx context.Context, path ...string) *graphql.CollectedField {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return nil
	}
	field := fc.Field
	oc := graphql.GetOperationContext(ctx)
walk:
	for _, name := range path {
		for _, f := range graphql.CollectFields(oc, field.Selections, nil) {
			if f.Alias == name {
				field = f
				continue walk
			}
		}
		return nil
	}
	return &field
}

func hasCollectedField(ctx context.Context, path ...string) bool {
	if graphql.GetFieldContext(ctx) == nil {
		return true
	}
	return collectedField(ctx, path...) != nil
}

const (
	edgesField      = "edges"
	nodeField       = "node"
	pageInfoField   = "pageInfo"
	totalCountField = "totalCount"
)

func paginateLimit(first, last *int) int {
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	return limit
}

// AlertEdge is the edge representation of Alert.
type AlertEdge struct {
	Node   *Alert `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// AlertConnection is the connection containing edges to Alert.
type AlertConnection struct {
	Edges      []*AlertEdge `json:"edges"`
	PageInfo   PageInfo     `json:"pageInfo"`
	TotalCount int          `json:"totalCount"`
}

func (c *AlertConnection) build(nodes []*Alert, pager *alertPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Alert
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Alert {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Alert {
			return nodes[i]
		}
	}
	c.Edges = make([]*AlertEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &AlertEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// AlertPaginateOption enables pagination customization.
type AlertPaginateOption func(*alertPager) error

// WithAlertOrder configures pagination ordering.
func WithAlertOrder(order *AlertOrder) AlertPaginateOption {
	if order == nil {
		order = DefaultAlertOrder
	}
	o := *order
	return func(pager *alertPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultAlertOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithAlertFilter configures pagination filter.
func WithAlertFilter(filter func(*AlertQuery) (*AlertQuery, error)) AlertPaginateOption {
	return func(pager *alertPager) error {
		if filter == nil {
			return errors.New("AlertQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type alertPager struct {
	reverse bool
	order   *AlertOrder
	filter  func(*AlertQuery) (*AlertQuery, error)
}

func newAlertPager(opts []AlertPaginateOption, reverse bool) (*alertPager, error) {
	pager := &alertPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultAlertOrder
	}
	return pager, nil
}

func (p *alertPager) applyFilter(query *AlertQuery) (*AlertQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *alertPager) toCursor(a *Alert) Cursor {
	return p.order.Field.toCursor(a)
}

func (p *alertPager) applyCursors(query *AlertQuery, after, before *Cursor) (*AlertQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultAlertOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *alertPager) applyOrder(query *AlertQuery) *AlertQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultAlertOrder.Field {
		query = query.Order(DefaultAlertOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *alertPager) orderExpr(query *AlertQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultAlertOrder.Field {
			b.Comma().Ident(DefaultAlertOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Alert.
func (a *AlertQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...AlertPaginateOption,
) (*AlertConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newAlertPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if a, err = pager.applyFilter(a); err != nil {
		return nil, err
	}
	conn := &AlertConnection{Edges: []*AlertEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = a.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if a, err = pager.applyCursors(a, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		a.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := a.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	a = pager.applyOrder(a)
	nodes, err := a.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// AlertOrderField defines the ordering field of Alert.
type AlertOrderField struct {
	// Value extracts the ordering value from the given Alert.
	Value    func(*Alert) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) alert.OrderOption
	toCursor func(*Alert) Cursor
}

// AlertOrder defines the ordering of Alert.
type AlertOrder struct {
	Direction OrderDirection   `json:"direction"`
	Field     *AlertOrderField `json:"field"`
}

// DefaultAlertOrder is the default ordering of Alert.
var DefaultAlertOrder = &AlertOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &AlertOrderField{
		Value: func(a *Alert) (ent.Value, error) {
			return a.ID, nil
		},
		column: alert.FieldID,
		toTerm: alert.ByID,
		toCursor: func(a *Alert) Cursor {
			return Cursor{ID: a.ID}
		},
	},
}

// ToEdge converts Alert into AlertEdge.
func (a *Alert) ToEdge(order *AlertOrder) *AlertEdge {
	if order == nil {
		order = DefaultAlertOrder
	}
	return &AlertEdge{
		Node:   a,
		Cursor: order.Field.toCursor(a),
	}
}

// CounterEdge is the edge representation of Counter.
type CounterEdge struct {
	Node   *Counter `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// CounterConnection is the connection containing edges to Counter.
type CounterConnection struct {
	Edges      []*CounterEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

func (c *CounterConnection) build(nodes []*Counter, pager *counterPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Counter
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Counter {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Counter {
			return nodes[i]
		}
	}
	c.Edges = make([]*CounterEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &CounterEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// CounterPaginateOption enables pagination customization.
type CounterPaginateOption func(*counterPager) error

// WithCounterOrder configures pagination ordering.
func WithCounterOrder(order *CounterOrder) CounterPaginateOption {
	if order == nil {
		order = DefaultCounterOrder
	}
	o := *order
	return func(pager *counterPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCounterOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCounterFilter configures pagination filter.
func WithCounterFilter(filter func(*CounterQuery) (*CounterQuery, error)) CounterPaginateOption {
	return func(pager *counterPager) error {
		if filter == nil {
			return errors.New("CounterQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type counterPager struct {
	reverse bool
	order   *CounterOrder
	filter  func(*CounterQuery) (*CounterQuery, error)
}

func newCounterPager(opts []CounterPaginateOption, reverse bool) (*counterPager, error) {
	pager := &counterPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCounterOrder
	}
	return pager, nil
}

func (p *counterPager) applyFilter(query *CounterQuery) (*CounterQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *counterPager) toCursor(c *Counter) Cursor {
	return p.order.Field.toCursor(c)
}

func (p *counterPager) applyCursors(query *CounterQuery, after, before *Cursor) (*CounterQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultCounterOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *counterPager) applyOrder(query *CounterQuery) *CounterQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultCounterOrder.Field {
		query = query.Order(DefaultCounterOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *counterPager) orderExpr(query *CounterQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultCounterOrder.Field {
			b.Comma().Ident(DefaultCounterOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Counter.
func (c *CounterQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CounterPaginateOption,
) (*CounterConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCounterPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if c, err = pager.applyFilter(c); err != nil {
		return nil, err
	}
	conn := &CounterConnection{Edges: []*CounterEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = c.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if c, err = pager.applyCursors(c, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		c.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := c.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	c = pager.applyOrder(c)
	nodes, err := c.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// CounterOrderField defines the ordering field of Counter.
type CounterOrderField struct {
	// Value extracts the ordering value from the given Counter.
	Value    func(*Counter) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) counter.OrderOption
	toCursor func(*Counter) Cursor
}

// CounterOrder defines the ordering of Counter.
type CounterOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *CounterOrderField `json:"field"`
}

// DefaultCounterOrder is the default ordering of Counter.
var DefaultCounterOrder = &CounterOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &CounterOrderField{
		Value: func(c *Counter) (ent.Value, error) {
			return c.ID, nil
		},
		column: counter.FieldID,
		toTerm: counter.ByID,
		toCursor: func(c *Counter) Cursor {
			return Cursor{ID: c.ID}
		},
	},
}

// ToEdge converts Counter into CounterEdge.
func (c *Counter) ToEdge(order *CounterOrder) *CounterEdge {
	if order == nil {
		order = DefaultCounterOrder
	}
	return &CounterEdge{
		Node:   c,
		Cursor: order.Field.toCursor(c),
	}
}

// FailureEdge is the edge representation of Failure.
type FailureEdge struct {
	Node   *Failure `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// FailureConnection is the connection containing edges to Failure.
type FailureConnection struct {
	Edges      []*FailureEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

func (c *FailureConnection) build(nodes []*Failure, pager *failurePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Failure
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Failure {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Failure {
			return nodes[i]
		}
	}
	c.Edges = make([]*FailureEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &FailureEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// FailurePaginateOption enables pagination customization.
type FailurePaginateOption func(*failurePager) error

// WithFailureOrder configures pagination ordering.
func WithFailureOrder(order *FailureOrder) FailurePaginateOption {
	if order == nil {
		order = DefaultFailureOrder
	}
	o := *order
	return func(pager *failurePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultFailureOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithFailureFilter configures pagination filter.
func WithFailureFilter(filter func(*FailureQuery) (*FailureQuery, error)) FailurePaginateOption {
	return func(pager *failurePager) error {
		if filter == nil {
			return errors.New("FailureQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type failurePager struct {
	reverse bool
	order   *FailureOrder
	filter  func(*FailureQuery) (*FailureQuery, error)
}

func newFailurePager(opts []FailurePaginateOption, reverse bool) (*failurePager, error) {
	pager := &failurePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultFailureOrder
	}
	return pager, nil
}

func (p *failurePager) applyFilter(query *FailureQuery) (*FailureQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *failurePager) toCursor(f *Failure) Cursor {
	return p.order.Field.toCursor(f)
}

func (p *failurePager) applyCursors(query *FailureQuery, after, before *Cursor) (*FailureQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultFailureOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *failurePager) applyOrder(query *FailureQuery) *FailureQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultFailureOrder.Field {
		query = query.Order(DefaultFailureOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *failurePager) orderExpr(query *FailureQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultFailureOrder.Field {
			b.Comma().Ident(DefaultFailureOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Failure.
func (f *FailureQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...FailurePaginateOption,
) (*FailureConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newFailurePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if f, err = pager.applyFilter(f); err != nil {
		return nil, err
	}
	conn := &FailureConnection{Edges: []*FailureEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = f.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if f, err = pager.applyCursors(f, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		f.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := f.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	f = pager.applyOrder(f)
	nodes, err := f.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// FailureOrderField defines the ordering field of Failure.
type FailureOrderField struct {
	// Value extracts the ordering value from the given Failure.
	Value    func(*Failure) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) failure.OrderOption
	toCursor func(*Failure) Cursor
}

// FailureOrder defines the ordering of Failure.
type FailureOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *FailureOrderField `json:"field"`
}

// DefaultFailureOrder is the default ordering of Failure.
var DefaultFailureOrder = &FailureOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &FailureOrderField{
		Value: func(f *Failure) (ent.Value, error) {
			return f.ID, nil
		},
		column: failure.FieldID,
		toTerm: failure.ByID,
		toCursor: func(f *Failure) Cursor {
			return Cursor{ID: f.ID}
		},
	},
}

// ToEdge converts Failure into FailureEdge.
func (f *Failure) ToEdge(order *FailureOrder) *FailureEdge {
	if order == nil {
		order = DefaultFailureOrder
	}
	return &FailureEdge{
		Node:   f,
		Cursor: order.Field.toCursor(f),
	}
}

// FileEdge is the edge representation of File.
type FileEdge struct {
	Node   *File  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// FileConnection is the connection containing edges to File.
type FileConnection struct {
	Edges      []*FileEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

func (c *FileConnection) build(nodes []*File, pager *filePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *File
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *File {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *File {
			return nodes[i]
		}
	}
	c.Edges = make([]*FileEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &FileEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// FilePaginateOption enables pagination customization.
type FilePaginateOption func(*filePager) error

// WithFileOrder configures pagination ordering.
func WithFileOrder(order *FileOrder) FilePaginateOption {
	if order == nil {
		order = DefaultFileOrder
	}
	o := *order
	return func(pager *filePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultFileOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithFileFilter configures pagination filter.
func WithFileFilter(filter func(*FileQuery) (*FileQuery, error)) FilePaginateOption {
	return func(pager *filePager) error {
		if filter == nil {
			return errors.New("FileQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type filePager struct {
	reverse bool
	order   *FileOrder
	filter  func(*FileQuery) (*FileQuery, error)
}

func newFilePager(opts []FilePaginateOption, reverse bool) (*filePager, error) {
	pager := &filePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultFileOrder
	}
	return pager, nil
}

func (p *filePager) applyFilter(query *FileQuery) (*FileQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *filePager) toCursor(f *File) Cursor {
	return p.order.Field.toCursor(f)
}

func (p *filePager) applyCursors(query *FileQuery, after, before *Cursor) (*FileQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultFileOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *filePager) applyOrder(query *FileQuery) *FileQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultFileOrder.Field {
		query = query.Order(DefaultFileOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *filePager) orderExpr(query *FileQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultFileOrder.Field {
			b.Comma().Ident(DefaultFileOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to File.
func (f *FileQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...FilePaginateOption,
) (*FileConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newFilePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if f, err = pager.applyFilter(f); err != nil {
		return nil, err
	}
	conn := &FileConnection{Edges: []*FileEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = f.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if f, err = pager.applyCursors(f, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		f.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := f.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	f = pager.applyOrder(f)
	nodes, err := f.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// FileOrderField defines the ordering field of File.
type FileOrderField struct {
	// Value extracts the ordering value from the given File.
	Value    func(*File) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) file.OrderOption
	toCursor func(*File) Cursor
}

// FileOrder defines the ordering of File.
type FileOrder struct {
	Direction OrderDirection  `json:"direction"`
	Field     *FileOrderField `json:"field"`
}

// DefaultFileOrder is the default ordering of File.
var DefaultFileOrder = &FileOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &FileOrderField{
		Value: func(f *File) (ent.Value, error) {
			return f.ID, nil
		},
		column: file.FieldID,
		toTerm: file.ByID,
		toCursor: func(f *File) Cursor {
			return Cursor{ID: f.ID}
		},
	},
}

// ToEdge converts File into FileEdge.
func (f *File) ToEdge(order *FileOrder) *FileEdge {
	if order == nil {
		order = DefaultFileOrder
	}
	return &FileEdge{
		Node:   f,
		Cursor: order.Field.toCursor(f),
	}
}

// IncidentEdge is the edge representation of Incident.
type IncidentEdge struct {
	Node   *Incident `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// IncidentConnection is the connection containing edges to Incident.
type IncidentConnection struct {
	Edges      []*IncidentEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *IncidentConnection) build(nodes []*Incident, pager *incidentPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Incident
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Incident {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Incident {
			return nodes[i]
		}
	}
	c.Edges = make([]*IncidentEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &IncidentEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// IncidentPaginateOption enables pagination customization.
type IncidentPaginateOption func(*incidentPager) error

// WithIncidentOrder configures pagination ordering.
func WithIncidentOrder(order *IncidentOrder) IncidentPaginateOption {
	if order == nil {
		order = DefaultIncidentOrder
	}
	o := *order
	return func(pager *incidentPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultIncidentOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithIncidentFilter configures pagination filter.
func WithIncidentFilter(filter func(*IncidentQuery) (*IncidentQuery, error)) IncidentPaginateOption {
	return func(pager *incidentPager) error {
		if filter == nil {
			return errors.New("IncidentQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type incidentPager struct {
	reverse bool
	order   *IncidentOrder
	filter  func(*IncidentQuery) (*IncidentQuery, error)
}

func newIncidentPager(opts []IncidentPaginateOption, reverse bool) (*incidentPager, error) {
	pager := &incidentPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultIncidentOrder
	}
	return pager, nil
}

func (p *incidentPager) applyFilter(query *IncidentQuery) (*IncidentQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *incidentPager) toCursor(i *Incident) Cursor {
	return p.order.Field.toCursor(i)
}

func (p *incidentPager) applyCursors(query *IncidentQuery, after, before *Cursor) (*IncidentQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultIncidentOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *incidentPager) applyOrder(query *IncidentQuery) *IncidentQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultIncidentOrder.Field {
		query = query.Order(DefaultIncidentOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *incidentPager) orderExpr(query *IncidentQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultIncidentOrder.Field {
			b.Comma().Ident(DefaultIncidentOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Incident.
func (i *IncidentQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...IncidentPaginateOption,
) (*IncidentConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newIncidentPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if i, err = pager.applyFilter(i); err != nil {
		return nil, err
	}
	conn := &IncidentConnection{Edges: []*IncidentEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = i.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if i, err = pager.applyCursors(i, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		i.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := i.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	i = pager.applyOrder(i)
	nodes, err := i.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// IncidentOrderField defines the ordering field of Incident.
type IncidentOrderField struct {
	// Value extracts the ordering value from the given Incident.
	Value    func(*Incident) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) incident.OrderOption
	toCursor func(*Incident) Cursor
}

// IncidentOrder defines the ordering of Incident.
type IncidentOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *IncidentOrderField `json:"field"`
}

// DefaultIncidentOrder is the default ordering of Incident.
var DefaultIncidentOrder = &IncidentOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &IncidentOrderField{
		Value: func(i *Incident) (ent.Value, error) {
			return i.ID, nil
		},
		column: incident.FieldID,
		toTerm: incident.ByID,
		toCursor: func(i *Incident) Cursor {
			return Cursor{ID: i.ID}
		},
	},
}

// ToEdge converts Incident into IncidentEdge.
func (i *Incident) ToEdge(order *IncidentOrder) *IncidentEdge {
	if order == nil {
		order = DefaultIncidentOrder
	}
	return &IncidentEdge{
		Node:   i,
		Cursor: order.Field.toCursor(i),
	}
}

// StatusEdge is the edge representation of Status.
type StatusEdge struct {
	Node   *Status `json:"node"`
	Cursor Cursor  `json:"cursor"`
}

// StatusConnection is the connection containing edges to Status.
type StatusConnection struct {
	Edges      []*StatusEdge `json:"edges"`
	PageInfo   PageInfo      `json:"pageInfo"`
	TotalCount int           `json:"totalCount"`
}

func (c *StatusConnection) build(nodes []*Status, pager *statusPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Status
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Status {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Status {
			return nodes[i]
		}
	}
	c.Edges = make([]*StatusEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &StatusEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// StatusPaginateOption enables pagination customization.
type StatusPaginateOption func(*statusPager) error

// WithStatusOrder configures pagination ordering.
func WithStatusOrder(order *StatusOrder) StatusPaginateOption {
	if order == nil {
		order = DefaultStatusOrder
	}
	o := *order
	return func(pager *statusPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultStatusOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithStatusFilter configures pagination filter.
func WithStatusFilter(filter func(*StatusQuery) (*StatusQuery, error)) StatusPaginateOption {
	return func(pager *statusPager) error {
		if filter == nil {
			return errors.New("StatusQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type statusPager struct {
	reverse bool
	order   *StatusOrder
	filter  func(*StatusQuery) (*StatusQuery, error)
}

func newStatusPager(opts []StatusPaginateOption, reverse bool) (*statusPager, error) {
	pager := &statusPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultStatusOrder
	}
	return pager, nil
}

func (p *statusPager) applyFilter(query *StatusQuery) (*StatusQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *statusPager) toCursor(s *Status) Cursor {
	return p.order.Field.toCursor(s)
}

func (p *statusPager) applyCursors(query *StatusQuery, after, before *Cursor) (*StatusQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultStatusOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *statusPager) applyOrder(query *StatusQuery) *StatusQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultStatusOrder.Field {
		query = query.Order(DefaultStatusOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *statusPager) orderExpr(query *StatusQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultStatusOrder.Field {
			b.Comma().Ident(DefaultStatusOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Status.
func (s *StatusQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...StatusPaginateOption,
) (*StatusConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newStatusPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if s, err = pager.applyFilter(s); err != nil {
		return nil, err
	}
	conn := &StatusConnection{Edges: []*StatusEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = s.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if s, err = pager.applyCursors(s, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		s.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := s.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	s = pager.applyOrder(s)
	nodes, err := s.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// StatusOrderField defines the ordering field of Status.
type StatusOrderField struct {
	// Value extracts the ordering value from the given Status.
	Value    func(*Status) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) status.OrderOption
	toCursor func(*Status) Cursor
}

// StatusOrder defines the ordering of Status.
type StatusOrder struct {
	Direction OrderDirection    `json:"direction"`
	Field     *StatusOrderField `json:"field"`
}

// DefaultStatusOrder is the default ordering of Status.
var DefaultStatusOrder = &StatusOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &StatusOrderField{
		Value: func(s *Status) (ent.Value, error) {
			return s.ID, nil
		},
		column: status.FieldID,
		toTerm: status.ByID,
		toCursor: func(s *Status) Cursor {
			return Cursor{ID: s.ID}
		},
	},
}

// ToEdge converts Status into StatusEdge.
func (s *Status) ToEdge(order *StatusOrder) *StatusEdge {
	if order == nil {
		order = DefaultStatusOrder
	}
	return &StatusEdge{
		Node:   s,
		Cursor: order.Field.toCursor(s),
	}
}
