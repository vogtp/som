// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"github.com/google/uuid"
	"github.com/vogtp/som/pkg/visualiser/webstatus/ent/ent/alert"
	"github.com/vogtp/som/pkg/visualiser/webstatus/ent/ent/counter"
	"github.com/vogtp/som/pkg/visualiser/webstatus/ent/ent/failure"
	"github.com/vogtp/som/pkg/visualiser/webstatus/ent/ent/file"
	"github.com/vogtp/som/pkg/visualiser/webstatus/ent/ent/incident"
	"github.com/vogtp/som/pkg/visualiser/webstatus/ent/ent/predicate"
	"github.com/vogtp/som/pkg/visualiser/webstatus/ent/ent/status"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAlert    = "Alert"
	TypeCounter  = "Counter"
	TypeFailure  = "Failure"
	TypeFile     = "File"
	TypeIncident = "Incident"
	TypeStatus   = "Status"
)

// AlertMutation represents an operation that mutates the Alert nodes in the graph.
type AlertMutation struct {
	config
	op               Op
	typ              string
	id               *int
	_Level           *int
	add_Level        *int
	_UUID            *uuid.UUID
	_IncidentID      *uuid.UUID
	_Name            *string
	_Time            *time.Time
	_Username        *string
	_Region          *string
	_ProbeOS         *string
	_ProbeHost       *string
	_Error           *string
	clearedFields    map[string]struct{}
	_Counters        map[int]struct{}
	removed_Counters map[int]struct{}
	cleared_Counters bool
	_Stati           map[int]struct{}
	removed_Stati    map[int]struct{}
	cleared_Stati    bool
	_Failures        map[int]struct{}
	removed_Failures map[int]struct{}
	cleared_Failures bool
	_Files           map[int]struct{}
	removed_Files    map[int]struct{}
	cleared_Files    bool
	done             bool
	oldValue         func(context.Context) (*Alert, error)
	predicates       []predicate.Alert
}

var _ ent.Mutation = (*AlertMutation)(nil)

// alertOption allows management of the mutation configuration using functional options.
type alertOption func(*AlertMutation)

// newAlertMutation creates new mutation for the Alert entity.
func newAlertMutation(c config, op Op, opts ...alertOption) *AlertMutation {
	m := &AlertMutation{
		config:        c,
		op:            op,
		typ:           TypeAlert,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAlertID sets the ID field of the mutation.
func withAlertID(id int) alertOption {
	return func(m *AlertMutation) {
		var (
			err   error
			once  sync.Once
			value *Alert
		)
		m.oldValue = func(ctx context.Context) (*Alert, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Alert.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAlert sets the old Alert of the mutation.
func withAlert(node *Alert) alertOption {
	return func(m *AlertMutation) {
		m.oldValue = func(context.Context) (*Alert, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AlertMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AlertMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AlertMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AlertMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Alert.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetLevel sets the "Level" field.
func (m *AlertMutation) SetLevel(i int) {
	m._Level = &i
	m.add_Level = nil
}

// Level returns the value of the "Level" field in the mutation.
func (m *AlertMutation) Level() (r int, exists bool) {
	v := m._Level
	if v == nil {
		return
	}
	return *v, true
}

// OldLevel returns the old "Level" field's value of the Alert entity.
// If the Alert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertMutation) OldLevel(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLevel: %w", err)
	}
	return oldValue.Level, nil
}

// AddLevel adds i to the "Level" field.
func (m *AlertMutation) AddLevel(i int) {
	if m.add_Level != nil {
		*m.add_Level += i
	} else {
		m.add_Level = &i
	}
}

// AddedLevel returns the value that was added to the "Level" field in this mutation.
func (m *AlertMutation) AddedLevel() (r int, exists bool) {
	v := m.add_Level
	if v == nil {
		return
	}
	return *v, true
}

// ResetLevel resets all changes to the "Level" field.
func (m *AlertMutation) ResetLevel() {
	m._Level = nil
	m.add_Level = nil
}

// SetUUID sets the "UUID" field.
func (m *AlertMutation) SetUUID(u uuid.UUID) {
	m._UUID = &u
}

// UUID returns the value of the "UUID" field in the mutation.
func (m *AlertMutation) UUID() (r uuid.UUID, exists bool) {
	v := m._UUID
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "UUID" field's value of the Alert entity.
// If the Alert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertMutation) OldUUID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "UUID" field.
func (m *AlertMutation) ResetUUID() {
	m._UUID = nil
}

// SetIncidentID sets the "IncidentID" field.
func (m *AlertMutation) SetIncidentID(u uuid.UUID) {
	m._IncidentID = &u
}

// IncidentID returns the value of the "IncidentID" field in the mutation.
func (m *AlertMutation) IncidentID() (r uuid.UUID, exists bool) {
	v := m._IncidentID
	if v == nil {
		return
	}
	return *v, true
}

// OldIncidentID returns the old "IncidentID" field's value of the Alert entity.
// If the Alert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertMutation) OldIncidentID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIncidentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIncidentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIncidentID: %w", err)
	}
	return oldValue.IncidentID, nil
}

// ResetIncidentID resets all changes to the "IncidentID" field.
func (m *AlertMutation) ResetIncidentID() {
	m._IncidentID = nil
}

// SetName sets the "Name" field.
func (m *AlertMutation) SetName(s string) {
	m._Name = &s
}

// Name returns the value of the "Name" field in the mutation.
func (m *AlertMutation) Name() (r string, exists bool) {
	v := m._Name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "Name" field's value of the Alert entity.
// If the Alert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "Name" field.
func (m *AlertMutation) ResetName() {
	m._Name = nil
}

// SetTime sets the "Time" field.
func (m *AlertMutation) SetTime(t time.Time) {
	m._Time = &t
}

// Time returns the value of the "Time" field in the mutation.
func (m *AlertMutation) Time() (r time.Time, exists bool) {
	v := m._Time
	if v == nil {
		return
	}
	return *v, true
}

// OldTime returns the old "Time" field's value of the Alert entity.
// If the Alert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertMutation) OldTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTime: %w", err)
	}
	return oldValue.Time, nil
}

// ResetTime resets all changes to the "Time" field.
func (m *AlertMutation) ResetTime() {
	m._Time = nil
}

// SetUsername sets the "Username" field.
func (m *AlertMutation) SetUsername(s string) {
	m._Username = &s
}

// Username returns the value of the "Username" field in the mutation.
func (m *AlertMutation) Username() (r string, exists bool) {
	v := m._Username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "Username" field's value of the Alert entity.
// If the Alert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "Username" field.
func (m *AlertMutation) ResetUsername() {
	m._Username = nil
}

// SetRegion sets the "Region" field.
func (m *AlertMutation) SetRegion(s string) {
	m._Region = &s
}

// Region returns the value of the "Region" field in the mutation.
func (m *AlertMutation) Region() (r string, exists bool) {
	v := m._Region
	if v == nil {
		return
	}
	return *v, true
}

// OldRegion returns the old "Region" field's value of the Alert entity.
// If the Alert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertMutation) OldRegion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegion: %w", err)
	}
	return oldValue.Region, nil
}

// ResetRegion resets all changes to the "Region" field.
func (m *AlertMutation) ResetRegion() {
	m._Region = nil
}

// SetProbeOS sets the "ProbeOS" field.
func (m *AlertMutation) SetProbeOS(s string) {
	m._ProbeOS = &s
}

// ProbeOS returns the value of the "ProbeOS" field in the mutation.
func (m *AlertMutation) ProbeOS() (r string, exists bool) {
	v := m._ProbeOS
	if v == nil {
		return
	}
	return *v, true
}

// OldProbeOS returns the old "ProbeOS" field's value of the Alert entity.
// If the Alert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertMutation) OldProbeOS(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProbeOS is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProbeOS requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProbeOS: %w", err)
	}
	return oldValue.ProbeOS, nil
}

// ResetProbeOS resets all changes to the "ProbeOS" field.
func (m *AlertMutation) ResetProbeOS() {
	m._ProbeOS = nil
}

// SetProbeHost sets the "ProbeHost" field.
func (m *AlertMutation) SetProbeHost(s string) {
	m._ProbeHost = &s
}

// ProbeHost returns the value of the "ProbeHost" field in the mutation.
func (m *AlertMutation) ProbeHost() (r string, exists bool) {
	v := m._ProbeHost
	if v == nil {
		return
	}
	return *v, true
}

// OldProbeHost returns the old "ProbeHost" field's value of the Alert entity.
// If the Alert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertMutation) OldProbeHost(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProbeHost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProbeHost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProbeHost: %w", err)
	}
	return oldValue.ProbeHost, nil
}

// ResetProbeHost resets all changes to the "ProbeHost" field.
func (m *AlertMutation) ResetProbeHost() {
	m._ProbeHost = nil
}

// SetError sets the "Error" field.
func (m *AlertMutation) SetError(s string) {
	m._Error = &s
}

// Error returns the value of the "Error" field in the mutation.
func (m *AlertMutation) Error() (r string, exists bool) {
	v := m._Error
	if v == nil {
		return
	}
	return *v, true
}

// OldError returns the old "Error" field's value of the Alert entity.
// If the Alert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AlertMutation) OldError(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldError is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldError requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldError: %w", err)
	}
	return oldValue.Error, nil
}

// ClearError clears the value of the "Error" field.
func (m *AlertMutation) ClearError() {
	m._Error = nil
	m.clearedFields[alert.FieldError] = struct{}{}
}

// ErrorCleared returns if the "Error" field was cleared in this mutation.
func (m *AlertMutation) ErrorCleared() bool {
	_, ok := m.clearedFields[alert.FieldError]
	return ok
}

// ResetError resets all changes to the "Error" field.
func (m *AlertMutation) ResetError() {
	m._Error = nil
	delete(m.clearedFields, alert.FieldError)
}

// AddCounterIDs adds the "Counters" edge to the Counter entity by ids.
func (m *AlertMutation) AddCounterIDs(ids ...int) {
	if m._Counters == nil {
		m._Counters = make(map[int]struct{})
	}
	for i := range ids {
		m._Counters[ids[i]] = struct{}{}
	}
}

// ClearCounters clears the "Counters" edge to the Counter entity.
func (m *AlertMutation) ClearCounters() {
	m.cleared_Counters = true
}

// CountersCleared reports if the "Counters" edge to the Counter entity was cleared.
func (m *AlertMutation) CountersCleared() bool {
	return m.cleared_Counters
}

// RemoveCounterIDs removes the "Counters" edge to the Counter entity by IDs.
func (m *AlertMutation) RemoveCounterIDs(ids ...int) {
	if m.removed_Counters == nil {
		m.removed_Counters = make(map[int]struct{})
	}
	for i := range ids {
		delete(m._Counters, ids[i])
		m.removed_Counters[ids[i]] = struct{}{}
	}
}

// RemovedCounters returns the removed IDs of the "Counters" edge to the Counter entity.
func (m *AlertMutation) RemovedCountersIDs() (ids []int) {
	for id := range m.removed_Counters {
		ids = append(ids, id)
	}
	return
}

// CountersIDs returns the "Counters" edge IDs in the mutation.
func (m *AlertMutation) CountersIDs() (ids []int) {
	for id := range m._Counters {
		ids = append(ids, id)
	}
	return
}

// ResetCounters resets all changes to the "Counters" edge.
func (m *AlertMutation) ResetCounters() {
	m._Counters = nil
	m.cleared_Counters = false
	m.removed_Counters = nil
}

// AddStatiIDs adds the "Stati" edge to the Status entity by ids.
func (m *AlertMutation) AddStatiIDs(ids ...int) {
	if m._Stati == nil {
		m._Stati = make(map[int]struct{})
	}
	for i := range ids {
		m._Stati[ids[i]] = struct{}{}
	}
}

// ClearStati clears the "Stati" edge to the Status entity.
func (m *AlertMutation) ClearStati() {
	m.cleared_Stati = true
}

// StatiCleared reports if the "Stati" edge to the Status entity was cleared.
func (m *AlertMutation) StatiCleared() bool {
	return m.cleared_Stati
}

// RemoveStatiIDs removes the "Stati" edge to the Status entity by IDs.
func (m *AlertMutation) RemoveStatiIDs(ids ...int) {
	if m.removed_Stati == nil {
		m.removed_Stati = make(map[int]struct{})
	}
	for i := range ids {
		delete(m._Stati, ids[i])
		m.removed_Stati[ids[i]] = struct{}{}
	}
}

// RemovedStati returns the removed IDs of the "Stati" edge to the Status entity.
func (m *AlertMutation) RemovedStatiIDs() (ids []int) {
	for id := range m.removed_Stati {
		ids = append(ids, id)
	}
	return
}

// StatiIDs returns the "Stati" edge IDs in the mutation.
func (m *AlertMutation) StatiIDs() (ids []int) {
	for id := range m._Stati {
		ids = append(ids, id)
	}
	return
}

// ResetStati resets all changes to the "Stati" edge.
func (m *AlertMutation) ResetStati() {
	m._Stati = nil
	m.cleared_Stati = false
	m.removed_Stati = nil
}

// AddFailureIDs adds the "Failures" edge to the Failure entity by ids.
func (m *AlertMutation) AddFailureIDs(ids ...int) {
	if m._Failures == nil {
		m._Failures = make(map[int]struct{})
	}
	for i := range ids {
		m._Failures[ids[i]] = struct{}{}
	}
}

// ClearFailures clears the "Failures" edge to the Failure entity.
func (m *AlertMutation) ClearFailures() {
	m.cleared_Failures = true
}

// FailuresCleared reports if the "Failures" edge to the Failure entity was cleared.
func (m *AlertMutation) FailuresCleared() bool {
	return m.cleared_Failures
}

// RemoveFailureIDs removes the "Failures" edge to the Failure entity by IDs.
func (m *AlertMutation) RemoveFailureIDs(ids ...int) {
	if m.removed_Failures == nil {
		m.removed_Failures = make(map[int]struct{})
	}
	for i := range ids {
		delete(m._Failures, ids[i])
		m.removed_Failures[ids[i]] = struct{}{}
	}
}

// RemovedFailures returns the removed IDs of the "Failures" edge to the Failure entity.
func (m *AlertMutation) RemovedFailuresIDs() (ids []int) {
	for id := range m.removed_Failures {
		ids = append(ids, id)
	}
	return
}

// FailuresIDs returns the "Failures" edge IDs in the mutation.
func (m *AlertMutation) FailuresIDs() (ids []int) {
	for id := range m._Failures {
		ids = append(ids, id)
	}
	return
}

// ResetFailures resets all changes to the "Failures" edge.
func (m *AlertMutation) ResetFailures() {
	m._Failures = nil
	m.cleared_Failures = false
	m.removed_Failures = nil
}

// AddFileIDs adds the "Files" edge to the File entity by ids.
func (m *AlertMutation) AddFileIDs(ids ...int) {
	if m._Files == nil {
		m._Files = make(map[int]struct{})
	}
	for i := range ids {
		m._Files[ids[i]] = struct{}{}
	}
}

// ClearFiles clears the "Files" edge to the File entity.
func (m *AlertMutation) ClearFiles() {
	m.cleared_Files = true
}

// FilesCleared reports if the "Files" edge to the File entity was cleared.
func (m *AlertMutation) FilesCleared() bool {
	return m.cleared_Files
}

// RemoveFileIDs removes the "Files" edge to the File entity by IDs.
func (m *AlertMutation) RemoveFileIDs(ids ...int) {
	if m.removed_Files == nil {
		m.removed_Files = make(map[int]struct{})
	}
	for i := range ids {
		delete(m._Files, ids[i])
		m.removed_Files[ids[i]] = struct{}{}
	}
}

// RemovedFiles returns the removed IDs of the "Files" edge to the File entity.
func (m *AlertMutation) RemovedFilesIDs() (ids []int) {
	for id := range m.removed_Files {
		ids = append(ids, id)
	}
	return
}

// FilesIDs returns the "Files" edge IDs in the mutation.
func (m *AlertMutation) FilesIDs() (ids []int) {
	for id := range m._Files {
		ids = append(ids, id)
	}
	return
}

// ResetFiles resets all changes to the "Files" edge.
func (m *AlertMutation) ResetFiles() {
	m._Files = nil
	m.cleared_Files = false
	m.removed_Files = nil
}

// Where appends a list predicates to the AlertMutation builder.
func (m *AlertMutation) Where(ps ...predicate.Alert) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AlertMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Alert).
func (m *AlertMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AlertMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m._Level != nil {
		fields = append(fields, alert.FieldLevel)
	}
	if m._UUID != nil {
		fields = append(fields, alert.FieldUUID)
	}
	if m._IncidentID != nil {
		fields = append(fields, alert.FieldIncidentID)
	}
	if m._Name != nil {
		fields = append(fields, alert.FieldName)
	}
	if m._Time != nil {
		fields = append(fields, alert.FieldTime)
	}
	if m._Username != nil {
		fields = append(fields, alert.FieldUsername)
	}
	if m._Region != nil {
		fields = append(fields, alert.FieldRegion)
	}
	if m._ProbeOS != nil {
		fields = append(fields, alert.FieldProbeOS)
	}
	if m._ProbeHost != nil {
		fields = append(fields, alert.FieldProbeHost)
	}
	if m._Error != nil {
		fields = append(fields, alert.FieldError)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AlertMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case alert.FieldLevel:
		return m.Level()
	case alert.FieldUUID:
		return m.UUID()
	case alert.FieldIncidentID:
		return m.IncidentID()
	case alert.FieldName:
		return m.Name()
	case alert.FieldTime:
		return m.Time()
	case alert.FieldUsername:
		return m.Username()
	case alert.FieldRegion:
		return m.Region()
	case alert.FieldProbeOS:
		return m.ProbeOS()
	case alert.FieldProbeHost:
		return m.ProbeHost()
	case alert.FieldError:
		return m.Error()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AlertMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case alert.FieldLevel:
		return m.OldLevel(ctx)
	case alert.FieldUUID:
		return m.OldUUID(ctx)
	case alert.FieldIncidentID:
		return m.OldIncidentID(ctx)
	case alert.FieldName:
		return m.OldName(ctx)
	case alert.FieldTime:
		return m.OldTime(ctx)
	case alert.FieldUsername:
		return m.OldUsername(ctx)
	case alert.FieldRegion:
		return m.OldRegion(ctx)
	case alert.FieldProbeOS:
		return m.OldProbeOS(ctx)
	case alert.FieldProbeHost:
		return m.OldProbeHost(ctx)
	case alert.FieldError:
		return m.OldError(ctx)
	}
	return nil, fmt.Errorf("unknown Alert field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AlertMutation) SetField(name string, value ent.Value) error {
	switch name {
	case alert.FieldLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLevel(v)
		return nil
	case alert.FieldUUID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case alert.FieldIncidentID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIncidentID(v)
		return nil
	case alert.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case alert.FieldTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTime(v)
		return nil
	case alert.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case alert.FieldRegion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegion(v)
		return nil
	case alert.FieldProbeOS:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProbeOS(v)
		return nil
	case alert.FieldProbeHost:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProbeHost(v)
		return nil
	case alert.FieldError:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetError(v)
		return nil
	}
	return fmt.Errorf("unknown Alert field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AlertMutation) AddedFields() []string {
	var fields []string
	if m.add_Level != nil {
		fields = append(fields, alert.FieldLevel)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AlertMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case alert.FieldLevel:
		return m.AddedLevel()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AlertMutation) AddField(name string, value ent.Value) error {
	switch name {
	case alert.FieldLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLevel(v)
		return nil
	}
	return fmt.Errorf("unknown Alert numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AlertMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(alert.FieldError) {
		fields = append(fields, alert.FieldError)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AlertMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AlertMutation) ClearField(name string) error {
	switch name {
	case alert.FieldError:
		m.ClearError()
		return nil
	}
	return fmt.Errorf("unknown Alert nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AlertMutation) ResetField(name string) error {
	switch name {
	case alert.FieldLevel:
		m.ResetLevel()
		return nil
	case alert.FieldUUID:
		m.ResetUUID()
		return nil
	case alert.FieldIncidentID:
		m.ResetIncidentID()
		return nil
	case alert.FieldName:
		m.ResetName()
		return nil
	case alert.FieldTime:
		m.ResetTime()
		return nil
	case alert.FieldUsername:
		m.ResetUsername()
		return nil
	case alert.FieldRegion:
		m.ResetRegion()
		return nil
	case alert.FieldProbeOS:
		m.ResetProbeOS()
		return nil
	case alert.FieldProbeHost:
		m.ResetProbeHost()
		return nil
	case alert.FieldError:
		m.ResetError()
		return nil
	}
	return fmt.Errorf("unknown Alert field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AlertMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m._Counters != nil {
		edges = append(edges, alert.EdgeCounters)
	}
	if m._Stati != nil {
		edges = append(edges, alert.EdgeStati)
	}
	if m._Failures != nil {
		edges = append(edges, alert.EdgeFailures)
	}
	if m._Files != nil {
		edges = append(edges, alert.EdgeFiles)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AlertMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case alert.EdgeCounters:
		ids := make([]ent.Value, 0, len(m._Counters))
		for id := range m._Counters {
			ids = append(ids, id)
		}
		return ids
	case alert.EdgeStati:
		ids := make([]ent.Value, 0, len(m._Stati))
		for id := range m._Stati {
			ids = append(ids, id)
		}
		return ids
	case alert.EdgeFailures:
		ids := make([]ent.Value, 0, len(m._Failures))
		for id := range m._Failures {
			ids = append(ids, id)
		}
		return ids
	case alert.EdgeFiles:
		ids := make([]ent.Value, 0, len(m._Files))
		for id := range m._Files {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AlertMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removed_Counters != nil {
		edges = append(edges, alert.EdgeCounters)
	}
	if m.removed_Stati != nil {
		edges = append(edges, alert.EdgeStati)
	}
	if m.removed_Failures != nil {
		edges = append(edges, alert.EdgeFailures)
	}
	if m.removed_Files != nil {
		edges = append(edges, alert.EdgeFiles)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AlertMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case alert.EdgeCounters:
		ids := make([]ent.Value, 0, len(m.removed_Counters))
		for id := range m.removed_Counters {
			ids = append(ids, id)
		}
		return ids
	case alert.EdgeStati:
		ids := make([]ent.Value, 0, len(m.removed_Stati))
		for id := range m.removed_Stati {
			ids = append(ids, id)
		}
		return ids
	case alert.EdgeFailures:
		ids := make([]ent.Value, 0, len(m.removed_Failures))
		for id := range m.removed_Failures {
			ids = append(ids, id)
		}
		return ids
	case alert.EdgeFiles:
		ids := make([]ent.Value, 0, len(m.removed_Files))
		for id := range m.removed_Files {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AlertMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleared_Counters {
		edges = append(edges, alert.EdgeCounters)
	}
	if m.cleared_Stati {
		edges = append(edges, alert.EdgeStati)
	}
	if m.cleared_Failures {
		edges = append(edges, alert.EdgeFailures)
	}
	if m.cleared_Files {
		edges = append(edges, alert.EdgeFiles)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AlertMutation) EdgeCleared(name string) bool {
	switch name {
	case alert.EdgeCounters:
		return m.cleared_Counters
	case alert.EdgeStati:
		return m.cleared_Stati
	case alert.EdgeFailures:
		return m.cleared_Failures
	case alert.EdgeFiles:
		return m.cleared_Files
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AlertMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Alert unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AlertMutation) ResetEdge(name string) error {
	switch name {
	case alert.EdgeCounters:
		m.ResetCounters()
		return nil
	case alert.EdgeStati:
		m.ResetStati()
		return nil
	case alert.EdgeFailures:
		m.ResetFailures()
		return nil
	case alert.EdgeFiles:
		m.ResetFiles()
		return nil
	}
	return fmt.Errorf("unknown Alert edge %s", name)
}

// CounterMutation represents an operation that mutates the Counter nodes in the graph.
type CounterMutation struct {
	config
	op            Op
	typ           string
	id            *int
	_Name         *string
	_Value        *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Counter, error)
	predicates    []predicate.Counter
}

var _ ent.Mutation = (*CounterMutation)(nil)

// counterOption allows management of the mutation configuration using functional options.
type counterOption func(*CounterMutation)

// newCounterMutation creates new mutation for the Counter entity.
func newCounterMutation(c config, op Op, opts ...counterOption) *CounterMutation {
	m := &CounterMutation{
		config:        c,
		op:            op,
		typ:           TypeCounter,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCounterID sets the ID field of the mutation.
func withCounterID(id int) counterOption {
	return func(m *CounterMutation) {
		var (
			err   error
			once  sync.Once
			value *Counter
		)
		m.oldValue = func(ctx context.Context) (*Counter, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Counter.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCounter sets the old Counter of the mutation.
func withCounter(node *Counter) counterOption {
	return func(m *CounterMutation) {
		m.oldValue = func(context.Context) (*Counter, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CounterMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CounterMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CounterMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CounterMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Counter.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "Name" field.
func (m *CounterMutation) SetName(s string) {
	m._Name = &s
}

// Name returns the value of the "Name" field in the mutation.
func (m *CounterMutation) Name() (r string, exists bool) {
	v := m._Name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "Name" field's value of the Counter entity.
// If the Counter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CounterMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "Name" field.
func (m *CounterMutation) ResetName() {
	m._Name = nil
}

// SetValue sets the "Value" field.
func (m *CounterMutation) SetValue(s string) {
	m._Value = &s
}

// Value returns the value of the "Value" field in the mutation.
func (m *CounterMutation) Value() (r string, exists bool) {
	v := m._Value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "Value" field's value of the Counter entity.
// If the Counter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CounterMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "Value" field.
func (m *CounterMutation) ResetValue() {
	m._Value = nil
}

// Where appends a list predicates to the CounterMutation builder.
func (m *CounterMutation) Where(ps ...predicate.Counter) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CounterMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Counter).
func (m *CounterMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CounterMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m._Name != nil {
		fields = append(fields, counter.FieldName)
	}
	if m._Value != nil {
		fields = append(fields, counter.FieldValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CounterMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case counter.FieldName:
		return m.Name()
	case counter.FieldValue:
		return m.Value()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CounterMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case counter.FieldName:
		return m.OldName(ctx)
	case counter.FieldValue:
		return m.OldValue(ctx)
	}
	return nil, fmt.Errorf("unknown Counter field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CounterMutation) SetField(name string, value ent.Value) error {
	switch name {
	case counter.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case counter.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	}
	return fmt.Errorf("unknown Counter field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CounterMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CounterMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CounterMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Counter numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CounterMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CounterMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CounterMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Counter nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CounterMutation) ResetField(name string) error {
	switch name {
	case counter.FieldName:
		m.ResetName()
		return nil
	case counter.FieldValue:
		m.ResetValue()
		return nil
	}
	return fmt.Errorf("unknown Counter field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CounterMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CounterMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CounterMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CounterMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CounterMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CounterMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CounterMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Counter unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CounterMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Counter edge %s", name)
}

// FailureMutation represents an operation that mutates the Failure nodes in the graph.
type FailureMutation struct {
	config
	op            Op
	typ           string
	id            *int
	_Error        *string
	_Idx          *int
	add_Idx       *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Failure, error)
	predicates    []predicate.Failure
}

var _ ent.Mutation = (*FailureMutation)(nil)

// failureOption allows management of the mutation configuration using functional options.
type failureOption func(*FailureMutation)

// newFailureMutation creates new mutation for the Failure entity.
func newFailureMutation(c config, op Op, opts ...failureOption) *FailureMutation {
	m := &FailureMutation{
		config:        c,
		op:            op,
		typ:           TypeFailure,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFailureID sets the ID field of the mutation.
func withFailureID(id int) failureOption {
	return func(m *FailureMutation) {
		var (
			err   error
			once  sync.Once
			value *Failure
		)
		m.oldValue = func(ctx context.Context) (*Failure, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Failure.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFailure sets the old Failure of the mutation.
func withFailure(node *Failure) failureOption {
	return func(m *FailureMutation) {
		m.oldValue = func(context.Context) (*Failure, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FailureMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FailureMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FailureMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FailureMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Failure.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetError sets the "Error" field.
func (m *FailureMutation) SetError(s string) {
	m._Error = &s
}

// Error returns the value of the "Error" field in the mutation.
func (m *FailureMutation) Error() (r string, exists bool) {
	v := m._Error
	if v == nil {
		return
	}
	return *v, true
}

// OldError returns the old "Error" field's value of the Failure entity.
// If the Failure object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FailureMutation) OldError(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldError is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldError requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldError: %w", err)
	}
	return oldValue.Error, nil
}

// ResetError resets all changes to the "Error" field.
func (m *FailureMutation) ResetError() {
	m._Error = nil
}

// SetIdx sets the "Idx" field.
func (m *FailureMutation) SetIdx(i int) {
	m._Idx = &i
	m.add_Idx = nil
}

// Idx returns the value of the "Idx" field in the mutation.
func (m *FailureMutation) Idx() (r int, exists bool) {
	v := m._Idx
	if v == nil {
		return
	}
	return *v, true
}

// OldIdx returns the old "Idx" field's value of the Failure entity.
// If the Failure object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FailureMutation) OldIdx(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIdx is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIdx requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIdx: %w", err)
	}
	return oldValue.Idx, nil
}

// AddIdx adds i to the "Idx" field.
func (m *FailureMutation) AddIdx(i int) {
	if m.add_Idx != nil {
		*m.add_Idx += i
	} else {
		m.add_Idx = &i
	}
}

// AddedIdx returns the value that was added to the "Idx" field in this mutation.
func (m *FailureMutation) AddedIdx() (r int, exists bool) {
	v := m.add_Idx
	if v == nil {
		return
	}
	return *v, true
}

// ResetIdx resets all changes to the "Idx" field.
func (m *FailureMutation) ResetIdx() {
	m._Idx = nil
	m.add_Idx = nil
}

// Where appends a list predicates to the FailureMutation builder.
func (m *FailureMutation) Where(ps ...predicate.Failure) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *FailureMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Failure).
func (m *FailureMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FailureMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m._Error != nil {
		fields = append(fields, failure.FieldError)
	}
	if m._Idx != nil {
		fields = append(fields, failure.FieldIdx)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FailureMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case failure.FieldError:
		return m.Error()
	case failure.FieldIdx:
		return m.Idx()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FailureMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case failure.FieldError:
		return m.OldError(ctx)
	case failure.FieldIdx:
		return m.OldIdx(ctx)
	}
	return nil, fmt.Errorf("unknown Failure field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FailureMutation) SetField(name string, value ent.Value) error {
	switch name {
	case failure.FieldError:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetError(v)
		return nil
	case failure.FieldIdx:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIdx(v)
		return nil
	}
	return fmt.Errorf("unknown Failure field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FailureMutation) AddedFields() []string {
	var fields []string
	if m.add_Idx != nil {
		fields = append(fields, failure.FieldIdx)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FailureMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case failure.FieldIdx:
		return m.AddedIdx()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FailureMutation) AddField(name string, value ent.Value) error {
	switch name {
	case failure.FieldIdx:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIdx(v)
		return nil
	}
	return fmt.Errorf("unknown Failure numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FailureMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FailureMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FailureMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Failure nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FailureMutation) ResetField(name string) error {
	switch name {
	case failure.FieldError:
		m.ResetError()
		return nil
	case failure.FieldIdx:
		m.ResetIdx()
		return nil
	}
	return fmt.Errorf("unknown Failure field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FailureMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FailureMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FailureMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FailureMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FailureMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FailureMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FailureMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Failure unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FailureMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Failure edge %s", name)
}

// FileMutation represents an operation that mutates the File nodes in the graph.
type FileMutation struct {
	config
	op            Op
	typ           string
	id            *int
	_UUID         *uuid.UUID
	_Name         *string
	_Type         *string
	_Ext          *string
	_Size         *int
	add_Size      *int
	payload       *[]byte
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*File, error)
	predicates    []predicate.File
}

var _ ent.Mutation = (*FileMutation)(nil)

// fileOption allows management of the mutation configuration using functional options.
type fileOption func(*FileMutation)

// newFileMutation creates new mutation for the File entity.
func newFileMutation(c config, op Op, opts ...fileOption) *FileMutation {
	m := &FileMutation{
		config:        c,
		op:            op,
		typ:           TypeFile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFileID sets the ID field of the mutation.
func withFileID(id int) fileOption {
	return func(m *FileMutation) {
		var (
			err   error
			once  sync.Once
			value *File
		)
		m.oldValue = func(ctx context.Context) (*File, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().File.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFile sets the old File of the mutation.
func withFile(node *File) fileOption {
	return func(m *FileMutation) {
		m.oldValue = func(context.Context) (*File, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FileMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FileMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().File.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUUID sets the "UUID" field.
func (m *FileMutation) SetUUID(u uuid.UUID) {
	m._UUID = &u
}

// UUID returns the value of the "UUID" field in the mutation.
func (m *FileMutation) UUID() (r uuid.UUID, exists bool) {
	v := m._UUID
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "UUID" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldUUID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "UUID" field.
func (m *FileMutation) ResetUUID() {
	m._UUID = nil
}

// SetName sets the "Name" field.
func (m *FileMutation) SetName(s string) {
	m._Name = &s
}

// Name returns the value of the "Name" field in the mutation.
func (m *FileMutation) Name() (r string, exists bool) {
	v := m._Name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "Name" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "Name" field.
func (m *FileMutation) ResetName() {
	m._Name = nil
}

// SetType sets the "Type" field.
func (m *FileMutation) SetType(s string) {
	m._Type = &s
}

// GetType returns the value of the "Type" field in the mutation.
func (m *FileMutation) GetType() (r string, exists bool) {
	v := m._Type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "Type" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "Type" field.
func (m *FileMutation) ResetType() {
	m._Type = nil
}

// SetExt sets the "Ext" field.
func (m *FileMutation) SetExt(s string) {
	m._Ext = &s
}

// Ext returns the value of the "Ext" field in the mutation.
func (m *FileMutation) Ext() (r string, exists bool) {
	v := m._Ext
	if v == nil {
		return
	}
	return *v, true
}

// OldExt returns the old "Ext" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldExt(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExt: %w", err)
	}
	return oldValue.Ext, nil
}

// ResetExt resets all changes to the "Ext" field.
func (m *FileMutation) ResetExt() {
	m._Ext = nil
}

// SetSize sets the "Size" field.
func (m *FileMutation) SetSize(i int) {
	m._Size = &i
	m.add_Size = nil
}

// Size returns the value of the "Size" field in the mutation.
func (m *FileMutation) Size() (r int, exists bool) {
	v := m._Size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "Size" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldSize(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// AddSize adds i to the "Size" field.
func (m *FileMutation) AddSize(i int) {
	if m.add_Size != nil {
		*m.add_Size += i
	} else {
		m.add_Size = &i
	}
}

// AddedSize returns the value that was added to the "Size" field in this mutation.
func (m *FileMutation) AddedSize() (r int, exists bool) {
	v := m.add_Size
	if v == nil {
		return
	}
	return *v, true
}

// ResetSize resets all changes to the "Size" field.
func (m *FileMutation) ResetSize() {
	m._Size = nil
	m.add_Size = nil
}

// SetPayload sets the "payload" field.
func (m *FileMutation) SetPayload(b []byte) {
	m.payload = &b
}

// Payload returns the value of the "payload" field in the mutation.
func (m *FileMutation) Payload() (r []byte, exists bool) {
	v := m.payload
	if v == nil {
		return
	}
	return *v, true
}

// OldPayload returns the old "payload" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldPayload(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPayload is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPayload requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayload: %w", err)
	}
	return oldValue.Payload, nil
}

// ResetPayload resets all changes to the "payload" field.
func (m *FileMutation) ResetPayload() {
	m.payload = nil
}

// Where appends a list predicates to the FileMutation builder.
func (m *FileMutation) Where(ps ...predicate.File) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *FileMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (File).
func (m *FileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FileMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m._UUID != nil {
		fields = append(fields, file.FieldUUID)
	}
	if m._Name != nil {
		fields = append(fields, file.FieldName)
	}
	if m._Type != nil {
		fields = append(fields, file.FieldType)
	}
	if m._Ext != nil {
		fields = append(fields, file.FieldExt)
	}
	if m._Size != nil {
		fields = append(fields, file.FieldSize)
	}
	if m.payload != nil {
		fields = append(fields, file.FieldPayload)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case file.FieldUUID:
		return m.UUID()
	case file.FieldName:
		return m.Name()
	case file.FieldType:
		return m.GetType()
	case file.FieldExt:
		return m.Ext()
	case file.FieldSize:
		return m.Size()
	case file.FieldPayload:
		return m.Payload()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case file.FieldUUID:
		return m.OldUUID(ctx)
	case file.FieldName:
		return m.OldName(ctx)
	case file.FieldType:
		return m.OldType(ctx)
	case file.FieldExt:
		return m.OldExt(ctx)
	case file.FieldSize:
		return m.OldSize(ctx)
	case file.FieldPayload:
		return m.OldPayload(ctx)
	}
	return nil, fmt.Errorf("unknown File field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case file.FieldUUID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case file.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case file.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case file.FieldExt:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExt(v)
		return nil
	case file.FieldSize:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	case file.FieldPayload:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayload(v)
		return nil
	}
	return fmt.Errorf("unknown File field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FileMutation) AddedFields() []string {
	var fields []string
	if m.add_Size != nil {
		fields = append(fields, file.FieldSize)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FileMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case file.FieldSize:
		return m.AddedSize()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileMutation) AddField(name string, value ent.Value) error {
	switch name {
	case file.FieldSize:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSize(v)
		return nil
	}
	return fmt.Errorf("unknown File numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FileMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FileMutation) ClearField(name string) error {
	return fmt.Errorf("unknown File nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FileMutation) ResetField(name string) error {
	switch name {
	case file.FieldUUID:
		m.ResetUUID()
		return nil
	case file.FieldName:
		m.ResetName()
		return nil
	case file.FieldType:
		m.ResetType()
		return nil
	case file.FieldExt:
		m.ResetExt()
		return nil
	case file.FieldSize:
		m.ResetSize()
		return nil
	case file.FieldPayload:
		m.ResetPayload()
		return nil
	}
	return fmt.Errorf("unknown File field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FileMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FileMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FileMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FileMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FileMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown File unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FileMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown File edge %s", name)
}

// IncidentMutation represents an operation that mutates the Incident nodes in the graph.
type IncidentMutation struct {
	config
	op               Op
	typ              string
	id               *int
	_Level           *int
	add_Level        *int
	_Start           *time.Time
	_End             *time.Time
	_State           *[]byte
	_UUID            *uuid.UUID
	_IncidentID      *uuid.UUID
	_Name            *string
	_Time            *time.Time
	_Username        *string
	_Region          *string
	_ProbeOS         *string
	_ProbeHost       *string
	_Error           *string
	clearedFields    map[string]struct{}
	_Counters        map[int]struct{}
	removed_Counters map[int]struct{}
	cleared_Counters bool
	_Stati           map[int]struct{}
	removed_Stati    map[int]struct{}
	cleared_Stati    bool
	_Failures        map[int]struct{}
	removed_Failures map[int]struct{}
	cleared_Failures bool
	_Files           map[int]struct{}
	removed_Files    map[int]struct{}
	cleared_Files    bool
	done             bool
	oldValue         func(context.Context) (*Incident, error)
	predicates       []predicate.Incident
}

var _ ent.Mutation = (*IncidentMutation)(nil)

// incidentOption allows management of the mutation configuration using functional options.
type incidentOption func(*IncidentMutation)

// newIncidentMutation creates new mutation for the Incident entity.
func newIncidentMutation(c config, op Op, opts ...incidentOption) *IncidentMutation {
	m := &IncidentMutation{
		config:        c,
		op:            op,
		typ:           TypeIncident,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIncidentID sets the ID field of the mutation.
func withIncidentID(id int) incidentOption {
	return func(m *IncidentMutation) {
		var (
			err   error
			once  sync.Once
			value *Incident
		)
		m.oldValue = func(ctx context.Context) (*Incident, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Incident.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIncident sets the old Incident of the mutation.
func withIncident(node *Incident) incidentOption {
	return func(m *IncidentMutation) {
		m.oldValue = func(context.Context) (*Incident, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IncidentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IncidentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IncidentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IncidentMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Incident.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetLevel sets the "Level" field.
func (m *IncidentMutation) SetLevel(i int) {
	m._Level = &i
	m.add_Level = nil
}

// Level returns the value of the "Level" field in the mutation.
func (m *IncidentMutation) Level() (r int, exists bool) {
	v := m._Level
	if v == nil {
		return
	}
	return *v, true
}

// OldLevel returns the old "Level" field's value of the Incident entity.
// If the Incident object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMutation) OldLevel(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLevel: %w", err)
	}
	return oldValue.Level, nil
}

// AddLevel adds i to the "Level" field.
func (m *IncidentMutation) AddLevel(i int) {
	if m.add_Level != nil {
		*m.add_Level += i
	} else {
		m.add_Level = &i
	}
}

// AddedLevel returns the value that was added to the "Level" field in this mutation.
func (m *IncidentMutation) AddedLevel() (r int, exists bool) {
	v := m.add_Level
	if v == nil {
		return
	}
	return *v, true
}

// ResetLevel resets all changes to the "Level" field.
func (m *IncidentMutation) ResetLevel() {
	m._Level = nil
	m.add_Level = nil
}

// SetStart sets the "Start" field.
func (m *IncidentMutation) SetStart(t time.Time) {
	m._Start = &t
}

// Start returns the value of the "Start" field in the mutation.
func (m *IncidentMutation) Start() (r time.Time, exists bool) {
	v := m._Start
	if v == nil {
		return
	}
	return *v, true
}

// OldStart returns the old "Start" field's value of the Incident entity.
// If the Incident object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMutation) OldStart(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStart: %w", err)
	}
	return oldValue.Start, nil
}

// ResetStart resets all changes to the "Start" field.
func (m *IncidentMutation) ResetStart() {
	m._Start = nil
}

// SetEnd sets the "End" field.
func (m *IncidentMutation) SetEnd(t time.Time) {
	m._End = &t
}

// End returns the value of the "End" field in the mutation.
func (m *IncidentMutation) End() (r time.Time, exists bool) {
	v := m._End
	if v == nil {
		return
	}
	return *v, true
}

// OldEnd returns the old "End" field's value of the Incident entity.
// If the Incident object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMutation) OldEnd(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnd: %w", err)
	}
	return oldValue.End, nil
}

// ResetEnd resets all changes to the "End" field.
func (m *IncidentMutation) ResetEnd() {
	m._End = nil
}

// SetState sets the "State" field.
func (m *IncidentMutation) SetState(b []byte) {
	m._State = &b
}

// State returns the value of the "State" field in the mutation.
func (m *IncidentMutation) State() (r []byte, exists bool) {
	v := m._State
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "State" field's value of the Incident entity.
// If the Incident object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMutation) OldState(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ResetState resets all changes to the "State" field.
func (m *IncidentMutation) ResetState() {
	m._State = nil
}

// SetUUID sets the "UUID" field.
func (m *IncidentMutation) SetUUID(u uuid.UUID) {
	m._UUID = &u
}

// UUID returns the value of the "UUID" field in the mutation.
func (m *IncidentMutation) UUID() (r uuid.UUID, exists bool) {
	v := m._UUID
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "UUID" field's value of the Incident entity.
// If the Incident object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMutation) OldUUID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "UUID" field.
func (m *IncidentMutation) ResetUUID() {
	m._UUID = nil
}

// SetIncidentID sets the "IncidentID" field.
func (m *IncidentMutation) SetIncidentID(u uuid.UUID) {
	m._IncidentID = &u
}

// IncidentID returns the value of the "IncidentID" field in the mutation.
func (m *IncidentMutation) IncidentID() (r uuid.UUID, exists bool) {
	v := m._IncidentID
	if v == nil {
		return
	}
	return *v, true
}

// OldIncidentID returns the old "IncidentID" field's value of the Incident entity.
// If the Incident object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMutation) OldIncidentID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIncidentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIncidentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIncidentID: %w", err)
	}
	return oldValue.IncidentID, nil
}

// ResetIncidentID resets all changes to the "IncidentID" field.
func (m *IncidentMutation) ResetIncidentID() {
	m._IncidentID = nil
}

// SetName sets the "Name" field.
func (m *IncidentMutation) SetName(s string) {
	m._Name = &s
}

// Name returns the value of the "Name" field in the mutation.
func (m *IncidentMutation) Name() (r string, exists bool) {
	v := m._Name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "Name" field's value of the Incident entity.
// If the Incident object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "Name" field.
func (m *IncidentMutation) ResetName() {
	m._Name = nil
}

// SetTime sets the "Time" field.
func (m *IncidentMutation) SetTime(t time.Time) {
	m._Time = &t
}

// Time returns the value of the "Time" field in the mutation.
func (m *IncidentMutation) Time() (r time.Time, exists bool) {
	v := m._Time
	if v == nil {
		return
	}
	return *v, true
}

// OldTime returns the old "Time" field's value of the Incident entity.
// If the Incident object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMutation) OldTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTime: %w", err)
	}
	return oldValue.Time, nil
}

// ResetTime resets all changes to the "Time" field.
func (m *IncidentMutation) ResetTime() {
	m._Time = nil
}

// SetUsername sets the "Username" field.
func (m *IncidentMutation) SetUsername(s string) {
	m._Username = &s
}

// Username returns the value of the "Username" field in the mutation.
func (m *IncidentMutation) Username() (r string, exists bool) {
	v := m._Username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "Username" field's value of the Incident entity.
// If the Incident object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "Username" field.
func (m *IncidentMutation) ResetUsername() {
	m._Username = nil
}

// SetRegion sets the "Region" field.
func (m *IncidentMutation) SetRegion(s string) {
	m._Region = &s
}

// Region returns the value of the "Region" field in the mutation.
func (m *IncidentMutation) Region() (r string, exists bool) {
	v := m._Region
	if v == nil {
		return
	}
	return *v, true
}

// OldRegion returns the old "Region" field's value of the Incident entity.
// If the Incident object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMutation) OldRegion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegion: %w", err)
	}
	return oldValue.Region, nil
}

// ResetRegion resets all changes to the "Region" field.
func (m *IncidentMutation) ResetRegion() {
	m._Region = nil
}

// SetProbeOS sets the "ProbeOS" field.
func (m *IncidentMutation) SetProbeOS(s string) {
	m._ProbeOS = &s
}

// ProbeOS returns the value of the "ProbeOS" field in the mutation.
func (m *IncidentMutation) ProbeOS() (r string, exists bool) {
	v := m._ProbeOS
	if v == nil {
		return
	}
	return *v, true
}

// OldProbeOS returns the old "ProbeOS" field's value of the Incident entity.
// If the Incident object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMutation) OldProbeOS(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProbeOS is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProbeOS requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProbeOS: %w", err)
	}
	return oldValue.ProbeOS, nil
}

// ResetProbeOS resets all changes to the "ProbeOS" field.
func (m *IncidentMutation) ResetProbeOS() {
	m._ProbeOS = nil
}

// SetProbeHost sets the "ProbeHost" field.
func (m *IncidentMutation) SetProbeHost(s string) {
	m._ProbeHost = &s
}

// ProbeHost returns the value of the "ProbeHost" field in the mutation.
func (m *IncidentMutation) ProbeHost() (r string, exists bool) {
	v := m._ProbeHost
	if v == nil {
		return
	}
	return *v, true
}

// OldProbeHost returns the old "ProbeHost" field's value of the Incident entity.
// If the Incident object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMutation) OldProbeHost(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProbeHost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProbeHost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProbeHost: %w", err)
	}
	return oldValue.ProbeHost, nil
}

// ResetProbeHost resets all changes to the "ProbeHost" field.
func (m *IncidentMutation) ResetProbeHost() {
	m._ProbeHost = nil
}

// SetError sets the "Error" field.
func (m *IncidentMutation) SetError(s string) {
	m._Error = &s
}

// Error returns the value of the "Error" field in the mutation.
func (m *IncidentMutation) Error() (r string, exists bool) {
	v := m._Error
	if v == nil {
		return
	}
	return *v, true
}

// OldError returns the old "Error" field's value of the Incident entity.
// If the Incident object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IncidentMutation) OldError(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldError is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldError requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldError: %w", err)
	}
	return oldValue.Error, nil
}

// ClearError clears the value of the "Error" field.
func (m *IncidentMutation) ClearError() {
	m._Error = nil
	m.clearedFields[incident.FieldError] = struct{}{}
}

// ErrorCleared returns if the "Error" field was cleared in this mutation.
func (m *IncidentMutation) ErrorCleared() bool {
	_, ok := m.clearedFields[incident.FieldError]
	return ok
}

// ResetError resets all changes to the "Error" field.
func (m *IncidentMutation) ResetError() {
	m._Error = nil
	delete(m.clearedFields, incident.FieldError)
}

// AddCounterIDs adds the "Counters" edge to the Counter entity by ids.
func (m *IncidentMutation) AddCounterIDs(ids ...int) {
	if m._Counters == nil {
		m._Counters = make(map[int]struct{})
	}
	for i := range ids {
		m._Counters[ids[i]] = struct{}{}
	}
}

// ClearCounters clears the "Counters" edge to the Counter entity.
func (m *IncidentMutation) ClearCounters() {
	m.cleared_Counters = true
}

// CountersCleared reports if the "Counters" edge to the Counter entity was cleared.
func (m *IncidentMutation) CountersCleared() bool {
	return m.cleared_Counters
}

// RemoveCounterIDs removes the "Counters" edge to the Counter entity by IDs.
func (m *IncidentMutation) RemoveCounterIDs(ids ...int) {
	if m.removed_Counters == nil {
		m.removed_Counters = make(map[int]struct{})
	}
	for i := range ids {
		delete(m._Counters, ids[i])
		m.removed_Counters[ids[i]] = struct{}{}
	}
}

// RemovedCounters returns the removed IDs of the "Counters" edge to the Counter entity.
func (m *IncidentMutation) RemovedCountersIDs() (ids []int) {
	for id := range m.removed_Counters {
		ids = append(ids, id)
	}
	return
}

// CountersIDs returns the "Counters" edge IDs in the mutation.
func (m *IncidentMutation) CountersIDs() (ids []int) {
	for id := range m._Counters {
		ids = append(ids, id)
	}
	return
}

// ResetCounters resets all changes to the "Counters" edge.
func (m *IncidentMutation) ResetCounters() {
	m._Counters = nil
	m.cleared_Counters = false
	m.removed_Counters = nil
}

// AddStatiIDs adds the "Stati" edge to the Status entity by ids.
func (m *IncidentMutation) AddStatiIDs(ids ...int) {
	if m._Stati == nil {
		m._Stati = make(map[int]struct{})
	}
	for i := range ids {
		m._Stati[ids[i]] = struct{}{}
	}
}

// ClearStati clears the "Stati" edge to the Status entity.
func (m *IncidentMutation) ClearStati() {
	m.cleared_Stati = true
}

// StatiCleared reports if the "Stati" edge to the Status entity was cleared.
func (m *IncidentMutation) StatiCleared() bool {
	return m.cleared_Stati
}

// RemoveStatiIDs removes the "Stati" edge to the Status entity by IDs.
func (m *IncidentMutation) RemoveStatiIDs(ids ...int) {
	if m.removed_Stati == nil {
		m.removed_Stati = make(map[int]struct{})
	}
	for i := range ids {
		delete(m._Stati, ids[i])
		m.removed_Stati[ids[i]] = struct{}{}
	}
}

// RemovedStati returns the removed IDs of the "Stati" edge to the Status entity.
func (m *IncidentMutation) RemovedStatiIDs() (ids []int) {
	for id := range m.removed_Stati {
		ids = append(ids, id)
	}
	return
}

// StatiIDs returns the "Stati" edge IDs in the mutation.
func (m *IncidentMutation) StatiIDs() (ids []int) {
	for id := range m._Stati {
		ids = append(ids, id)
	}
	return
}

// ResetStati resets all changes to the "Stati" edge.
func (m *IncidentMutation) ResetStati() {
	m._Stati = nil
	m.cleared_Stati = false
	m.removed_Stati = nil
}

// AddFailureIDs adds the "Failures" edge to the Failure entity by ids.
func (m *IncidentMutation) AddFailureIDs(ids ...int) {
	if m._Failures == nil {
		m._Failures = make(map[int]struct{})
	}
	for i := range ids {
		m._Failures[ids[i]] = struct{}{}
	}
}

// ClearFailures clears the "Failures" edge to the Failure entity.
func (m *IncidentMutation) ClearFailures() {
	m.cleared_Failures = true
}

// FailuresCleared reports if the "Failures" edge to the Failure entity was cleared.
func (m *IncidentMutation) FailuresCleared() bool {
	return m.cleared_Failures
}

// RemoveFailureIDs removes the "Failures" edge to the Failure entity by IDs.
func (m *IncidentMutation) RemoveFailureIDs(ids ...int) {
	if m.removed_Failures == nil {
		m.removed_Failures = make(map[int]struct{})
	}
	for i := range ids {
		delete(m._Failures, ids[i])
		m.removed_Failures[ids[i]] = struct{}{}
	}
}

// RemovedFailures returns the removed IDs of the "Failures" edge to the Failure entity.
func (m *IncidentMutation) RemovedFailuresIDs() (ids []int) {
	for id := range m.removed_Failures {
		ids = append(ids, id)
	}
	return
}

// FailuresIDs returns the "Failures" edge IDs in the mutation.
func (m *IncidentMutation) FailuresIDs() (ids []int) {
	for id := range m._Failures {
		ids = append(ids, id)
	}
	return
}

// ResetFailures resets all changes to the "Failures" edge.
func (m *IncidentMutation) ResetFailures() {
	m._Failures = nil
	m.cleared_Failures = false
	m.removed_Failures = nil
}

// AddFileIDs adds the "Files" edge to the File entity by ids.
func (m *IncidentMutation) AddFileIDs(ids ...int) {
	if m._Files == nil {
		m._Files = make(map[int]struct{})
	}
	for i := range ids {
		m._Files[ids[i]] = struct{}{}
	}
}

// ClearFiles clears the "Files" edge to the File entity.
func (m *IncidentMutation) ClearFiles() {
	m.cleared_Files = true
}

// FilesCleared reports if the "Files" edge to the File entity was cleared.
func (m *IncidentMutation) FilesCleared() bool {
	return m.cleared_Files
}

// RemoveFileIDs removes the "Files" edge to the File entity by IDs.
func (m *IncidentMutation) RemoveFileIDs(ids ...int) {
	if m.removed_Files == nil {
		m.removed_Files = make(map[int]struct{})
	}
	for i := range ids {
		delete(m._Files, ids[i])
		m.removed_Files[ids[i]] = struct{}{}
	}
}

// RemovedFiles returns the removed IDs of the "Files" edge to the File entity.
func (m *IncidentMutation) RemovedFilesIDs() (ids []int) {
	for id := range m.removed_Files {
		ids = append(ids, id)
	}
	return
}

// FilesIDs returns the "Files" edge IDs in the mutation.
func (m *IncidentMutation) FilesIDs() (ids []int) {
	for id := range m._Files {
		ids = append(ids, id)
	}
	return
}

// ResetFiles resets all changes to the "Files" edge.
func (m *IncidentMutation) ResetFiles() {
	m._Files = nil
	m.cleared_Files = false
	m.removed_Files = nil
}

// Where appends a list predicates to the IncidentMutation builder.
func (m *IncidentMutation) Where(ps ...predicate.Incident) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *IncidentMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Incident).
func (m *IncidentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IncidentMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m._Level != nil {
		fields = append(fields, incident.FieldLevel)
	}
	if m._Start != nil {
		fields = append(fields, incident.FieldStart)
	}
	if m._End != nil {
		fields = append(fields, incident.FieldEnd)
	}
	if m._State != nil {
		fields = append(fields, incident.FieldState)
	}
	if m._UUID != nil {
		fields = append(fields, incident.FieldUUID)
	}
	if m._IncidentID != nil {
		fields = append(fields, incident.FieldIncidentID)
	}
	if m._Name != nil {
		fields = append(fields, incident.FieldName)
	}
	if m._Time != nil {
		fields = append(fields, incident.FieldTime)
	}
	if m._Username != nil {
		fields = append(fields, incident.FieldUsername)
	}
	if m._Region != nil {
		fields = append(fields, incident.FieldRegion)
	}
	if m._ProbeOS != nil {
		fields = append(fields, incident.FieldProbeOS)
	}
	if m._ProbeHost != nil {
		fields = append(fields, incident.FieldProbeHost)
	}
	if m._Error != nil {
		fields = append(fields, incident.FieldError)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IncidentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case incident.FieldLevel:
		return m.Level()
	case incident.FieldStart:
		return m.Start()
	case incident.FieldEnd:
		return m.End()
	case incident.FieldState:
		return m.State()
	case incident.FieldUUID:
		return m.UUID()
	case incident.FieldIncidentID:
		return m.IncidentID()
	case incident.FieldName:
		return m.Name()
	case incident.FieldTime:
		return m.Time()
	case incident.FieldUsername:
		return m.Username()
	case incident.FieldRegion:
		return m.Region()
	case incident.FieldProbeOS:
		return m.ProbeOS()
	case incident.FieldProbeHost:
		return m.ProbeHost()
	case incident.FieldError:
		return m.Error()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IncidentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case incident.FieldLevel:
		return m.OldLevel(ctx)
	case incident.FieldStart:
		return m.OldStart(ctx)
	case incident.FieldEnd:
		return m.OldEnd(ctx)
	case incident.FieldState:
		return m.OldState(ctx)
	case incident.FieldUUID:
		return m.OldUUID(ctx)
	case incident.FieldIncidentID:
		return m.OldIncidentID(ctx)
	case incident.FieldName:
		return m.OldName(ctx)
	case incident.FieldTime:
		return m.OldTime(ctx)
	case incident.FieldUsername:
		return m.OldUsername(ctx)
	case incident.FieldRegion:
		return m.OldRegion(ctx)
	case incident.FieldProbeOS:
		return m.OldProbeOS(ctx)
	case incident.FieldProbeHost:
		return m.OldProbeHost(ctx)
	case incident.FieldError:
		return m.OldError(ctx)
	}
	return nil, fmt.Errorf("unknown Incident field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncidentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case incident.FieldLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLevel(v)
		return nil
	case incident.FieldStart:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStart(v)
		return nil
	case incident.FieldEnd:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnd(v)
		return nil
	case incident.FieldState:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case incident.FieldUUID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case incident.FieldIncidentID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIncidentID(v)
		return nil
	case incident.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case incident.FieldTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTime(v)
		return nil
	case incident.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case incident.FieldRegion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegion(v)
		return nil
	case incident.FieldProbeOS:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProbeOS(v)
		return nil
	case incident.FieldProbeHost:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProbeHost(v)
		return nil
	case incident.FieldError:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetError(v)
		return nil
	}
	return fmt.Errorf("unknown Incident field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IncidentMutation) AddedFields() []string {
	var fields []string
	if m.add_Level != nil {
		fields = append(fields, incident.FieldLevel)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IncidentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case incident.FieldLevel:
		return m.AddedLevel()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IncidentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case incident.FieldLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLevel(v)
		return nil
	}
	return fmt.Errorf("unknown Incident numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IncidentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(incident.FieldError) {
		fields = append(fields, incident.FieldError)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IncidentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IncidentMutation) ClearField(name string) error {
	switch name {
	case incident.FieldError:
		m.ClearError()
		return nil
	}
	return fmt.Errorf("unknown Incident nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IncidentMutation) ResetField(name string) error {
	switch name {
	case incident.FieldLevel:
		m.ResetLevel()
		return nil
	case incident.FieldStart:
		m.ResetStart()
		return nil
	case incident.FieldEnd:
		m.ResetEnd()
		return nil
	case incident.FieldState:
		m.ResetState()
		return nil
	case incident.FieldUUID:
		m.ResetUUID()
		return nil
	case incident.FieldIncidentID:
		m.ResetIncidentID()
		return nil
	case incident.FieldName:
		m.ResetName()
		return nil
	case incident.FieldTime:
		m.ResetTime()
		return nil
	case incident.FieldUsername:
		m.ResetUsername()
		return nil
	case incident.FieldRegion:
		m.ResetRegion()
		return nil
	case incident.FieldProbeOS:
		m.ResetProbeOS()
		return nil
	case incident.FieldProbeHost:
		m.ResetProbeHost()
		return nil
	case incident.FieldError:
		m.ResetError()
		return nil
	}
	return fmt.Errorf("unknown Incident field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IncidentMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m._Counters != nil {
		edges = append(edges, incident.EdgeCounters)
	}
	if m._Stati != nil {
		edges = append(edges, incident.EdgeStati)
	}
	if m._Failures != nil {
		edges = append(edges, incident.EdgeFailures)
	}
	if m._Files != nil {
		edges = append(edges, incident.EdgeFiles)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IncidentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case incident.EdgeCounters:
		ids := make([]ent.Value, 0, len(m._Counters))
		for id := range m._Counters {
			ids = append(ids, id)
		}
		return ids
	case incident.EdgeStati:
		ids := make([]ent.Value, 0, len(m._Stati))
		for id := range m._Stati {
			ids = append(ids, id)
		}
		return ids
	case incident.EdgeFailures:
		ids := make([]ent.Value, 0, len(m._Failures))
		for id := range m._Failures {
			ids = append(ids, id)
		}
		return ids
	case incident.EdgeFiles:
		ids := make([]ent.Value, 0, len(m._Files))
		for id := range m._Files {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IncidentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removed_Counters != nil {
		edges = append(edges, incident.EdgeCounters)
	}
	if m.removed_Stati != nil {
		edges = append(edges, incident.EdgeStati)
	}
	if m.removed_Failures != nil {
		edges = append(edges, incident.EdgeFailures)
	}
	if m.removed_Files != nil {
		edges = append(edges, incident.EdgeFiles)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IncidentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case incident.EdgeCounters:
		ids := make([]ent.Value, 0, len(m.removed_Counters))
		for id := range m.removed_Counters {
			ids = append(ids, id)
		}
		return ids
	case incident.EdgeStati:
		ids := make([]ent.Value, 0, len(m.removed_Stati))
		for id := range m.removed_Stati {
			ids = append(ids, id)
		}
		return ids
	case incident.EdgeFailures:
		ids := make([]ent.Value, 0, len(m.removed_Failures))
		for id := range m.removed_Failures {
			ids = append(ids, id)
		}
		return ids
	case incident.EdgeFiles:
		ids := make([]ent.Value, 0, len(m.removed_Files))
		for id := range m.removed_Files {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IncidentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleared_Counters {
		edges = append(edges, incident.EdgeCounters)
	}
	if m.cleared_Stati {
		edges = append(edges, incident.EdgeStati)
	}
	if m.cleared_Failures {
		edges = append(edges, incident.EdgeFailures)
	}
	if m.cleared_Files {
		edges = append(edges, incident.EdgeFiles)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IncidentMutation) EdgeCleared(name string) bool {
	switch name {
	case incident.EdgeCounters:
		return m.cleared_Counters
	case incident.EdgeStati:
		return m.cleared_Stati
	case incident.EdgeFailures:
		return m.cleared_Failures
	case incident.EdgeFiles:
		return m.cleared_Files
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IncidentMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Incident unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IncidentMutation) ResetEdge(name string) error {
	switch name {
	case incident.EdgeCounters:
		m.ResetCounters()
		return nil
	case incident.EdgeStati:
		m.ResetStati()
		return nil
	case incident.EdgeFailures:
		m.ResetFailures()
		return nil
	case incident.EdgeFiles:
		m.ResetFiles()
		return nil
	}
	return fmt.Errorf("unknown Incident edge %s", name)
}

// StatusMutation represents an operation that mutates the Status nodes in the graph.
type StatusMutation struct {
	config
	op            Op
	typ           string
	id            *int
	_Name         *string
	_Value        *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Status, error)
	predicates    []predicate.Status
}

var _ ent.Mutation = (*StatusMutation)(nil)

// statusOption allows management of the mutation configuration using functional options.
type statusOption func(*StatusMutation)

// newStatusMutation creates new mutation for the Status entity.
func newStatusMutation(c config, op Op, opts ...statusOption) *StatusMutation {
	m := &StatusMutation{
		config:        c,
		op:            op,
		typ:           TypeStatus,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStatusID sets the ID field of the mutation.
func withStatusID(id int) statusOption {
	return func(m *StatusMutation) {
		var (
			err   error
			once  sync.Once
			value *Status
		)
		m.oldValue = func(ctx context.Context) (*Status, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Status.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStatus sets the old Status of the mutation.
func withStatus(node *Status) statusOption {
	return func(m *StatusMutation) {
		m.oldValue = func(context.Context) (*Status, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StatusMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StatusMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StatusMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StatusMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Status.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "Name" field.
func (m *StatusMutation) SetName(s string) {
	m._Name = &s
}

// Name returns the value of the "Name" field in the mutation.
func (m *StatusMutation) Name() (r string, exists bool) {
	v := m._Name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "Name" field's value of the Status entity.
// If the Status object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatusMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "Name" field.
func (m *StatusMutation) ResetName() {
	m._Name = nil
}

// SetValue sets the "Value" field.
func (m *StatusMutation) SetValue(s string) {
	m._Value = &s
}

// Value returns the value of the "Value" field in the mutation.
func (m *StatusMutation) Value() (r string, exists bool) {
	v := m._Value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "Value" field's value of the Status entity.
// If the Status object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatusMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "Value" field.
func (m *StatusMutation) ResetValue() {
	m._Value = nil
}

// Where appends a list predicates to the StatusMutation builder.
func (m *StatusMutation) Where(ps ...predicate.Status) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *StatusMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Status).
func (m *StatusMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StatusMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m._Name != nil {
		fields = append(fields, status.FieldName)
	}
	if m._Value != nil {
		fields = append(fields, status.FieldValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StatusMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case status.FieldName:
		return m.Name()
	case status.FieldValue:
		return m.Value()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StatusMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case status.FieldName:
		return m.OldName(ctx)
	case status.FieldValue:
		return m.OldValue(ctx)
	}
	return nil, fmt.Errorf("unknown Status field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StatusMutation) SetField(name string, value ent.Value) error {
	switch name {
	case status.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case status.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	}
	return fmt.Errorf("unknown Status field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StatusMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StatusMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StatusMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Status numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StatusMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StatusMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StatusMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Status nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StatusMutation) ResetField(name string) error {
	switch name {
	case status.FieldName:
		m.ResetName()
		return nil
	case status.FieldValue:
		m.ResetValue()
		return nil
	}
	return fmt.Errorf("unknown Status field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StatusMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StatusMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StatusMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StatusMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StatusMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StatusMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StatusMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Status unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StatusMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Status edge %s", name)
}
