// Code generated by ent, DO NOT EDIT.

package ent

import (
	"errors"
	"fmt"
	"time"

	"github.com/google/uuid"
	"github.com/vogtp/som/pkg/visualiser/webstatus/ent/ent/alert"
	"github.com/vogtp/som/pkg/visualiser/webstatus/ent/ent/counter"
	"github.com/vogtp/som/pkg/visualiser/webstatus/ent/ent/failure"
	"github.com/vogtp/som/pkg/visualiser/webstatus/ent/ent/incident"
	"github.com/vogtp/som/pkg/visualiser/webstatus/ent/ent/predicate"
	"github.com/vogtp/som/pkg/visualiser/webstatus/ent/ent/status"
)

// AlertWhereInput represents a where input for filtering Alert queries.
type AlertWhereInput struct {
	Predicates []predicate.Alert  `json:"-"`
	Not        *AlertWhereInput   `json:"not,omitempty"`
	Or         []*AlertWhereInput `json:"or,omitempty"`
	And        []*AlertWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "Level" field predicates.
	Level      *int  `json:"level,omitempty"`
	LevelNEQ   *int  `json:"levelNEQ,omitempty"`
	LevelIn    []int `json:"levelIn,omitempty"`
	LevelNotIn []int `json:"levelNotIn,omitempty"`
	LevelGT    *int  `json:"levelGT,omitempty"`
	LevelGTE   *int  `json:"levelGTE,omitempty"`
	LevelLT    *int  `json:"levelLT,omitempty"`
	LevelLTE   *int  `json:"levelLTE,omitempty"`

	// "UUID" field predicates.
	UUID      *uuid.UUID  `json:"uuid,omitempty"`
	UUIDNEQ   *uuid.UUID  `json:"uuidNEQ,omitempty"`
	UUIDIn    []uuid.UUID `json:"uuidIn,omitempty"`
	UUIDNotIn []uuid.UUID `json:"uuidNotIn,omitempty"`
	UUIDGT    *uuid.UUID  `json:"uuidGT,omitempty"`
	UUIDGTE   *uuid.UUID  `json:"uuidGTE,omitempty"`
	UUIDLT    *uuid.UUID  `json:"uuidLT,omitempty"`
	UUIDLTE   *uuid.UUID  `json:"uuidLTE,omitempty"`

	// "IncidentID" field predicates.
	IncidentID      *uuid.UUID  `json:"incidentid,omitempty"`
	IncidentIDNEQ   *uuid.UUID  `json:"incidentidNEQ,omitempty"`
	IncidentIDIn    []uuid.UUID `json:"incidentidIn,omitempty"`
	IncidentIDNotIn []uuid.UUID `json:"incidentidNotIn,omitempty"`
	IncidentIDGT    *uuid.UUID  `json:"incidentidGT,omitempty"`
	IncidentIDGTE   *uuid.UUID  `json:"incidentidGTE,omitempty"`
	IncidentIDLT    *uuid.UUID  `json:"incidentidLT,omitempty"`
	IncidentIDLTE   *uuid.UUID  `json:"incidentidLTE,omitempty"`

	// "Name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "Time" field predicates.
	Time      *time.Time  `json:"time,omitempty"`
	TimeNEQ   *time.Time  `json:"timeNEQ,omitempty"`
	TimeIn    []time.Time `json:"timeIn,omitempty"`
	TimeNotIn []time.Time `json:"timeNotIn,omitempty"`
	TimeGT    *time.Time  `json:"timeGT,omitempty"`
	TimeGTE   *time.Time  `json:"timeGTE,omitempty"`
	TimeLT    *time.Time  `json:"timeLT,omitempty"`
	TimeLTE   *time.Time  `json:"timeLTE,omitempty"`

	// "Username" field predicates.
	Username             *string  `json:"username,omitempty"`
	UsernameNEQ          *string  `json:"usernameNEQ,omitempty"`
	UsernameIn           []string `json:"usernameIn,omitempty"`
	UsernameNotIn        []string `json:"usernameNotIn,omitempty"`
	UsernameGT           *string  `json:"usernameGT,omitempty"`
	UsernameGTE          *string  `json:"usernameGTE,omitempty"`
	UsernameLT           *string  `json:"usernameLT,omitempty"`
	UsernameLTE          *string  `json:"usernameLTE,omitempty"`
	UsernameContains     *string  `json:"usernameContains,omitempty"`
	UsernameHasPrefix    *string  `json:"usernameHasPrefix,omitempty"`
	UsernameHasSuffix    *string  `json:"usernameHasSuffix,omitempty"`
	UsernameEqualFold    *string  `json:"usernameEqualFold,omitempty"`
	UsernameContainsFold *string  `json:"usernameContainsFold,omitempty"`

	// "Region" field predicates.
	Region             *string  `json:"region,omitempty"`
	RegionNEQ          *string  `json:"regionNEQ,omitempty"`
	RegionIn           []string `json:"regionIn,omitempty"`
	RegionNotIn        []string `json:"regionNotIn,omitempty"`
	RegionGT           *string  `json:"regionGT,omitempty"`
	RegionGTE          *string  `json:"regionGTE,omitempty"`
	RegionLT           *string  `json:"regionLT,omitempty"`
	RegionLTE          *string  `json:"regionLTE,omitempty"`
	RegionContains     *string  `json:"regionContains,omitempty"`
	RegionHasPrefix    *string  `json:"regionHasPrefix,omitempty"`
	RegionHasSuffix    *string  `json:"regionHasSuffix,omitempty"`
	RegionEqualFold    *string  `json:"regionEqualFold,omitempty"`
	RegionContainsFold *string  `json:"regionContainsFold,omitempty"`

	// "ProbeOS" field predicates.
	ProbeOS             *string  `json:"probeos,omitempty"`
	ProbeOSNEQ          *string  `json:"probeosNEQ,omitempty"`
	ProbeOSIn           []string `json:"probeosIn,omitempty"`
	ProbeOSNotIn        []string `json:"probeosNotIn,omitempty"`
	ProbeOSGT           *string  `json:"probeosGT,omitempty"`
	ProbeOSGTE          *string  `json:"probeosGTE,omitempty"`
	ProbeOSLT           *string  `json:"probeosLT,omitempty"`
	ProbeOSLTE          *string  `json:"probeosLTE,omitempty"`
	ProbeOSContains     *string  `json:"probeosContains,omitempty"`
	ProbeOSHasPrefix    *string  `json:"probeosHasPrefix,omitempty"`
	ProbeOSHasSuffix    *string  `json:"probeosHasSuffix,omitempty"`
	ProbeOSEqualFold    *string  `json:"probeosEqualFold,omitempty"`
	ProbeOSContainsFold *string  `json:"probeosContainsFold,omitempty"`

	// "ProbeHost" field predicates.
	ProbeHost             *string  `json:"probehost,omitempty"`
	ProbeHostNEQ          *string  `json:"probehostNEQ,omitempty"`
	ProbeHostIn           []string `json:"probehostIn,omitempty"`
	ProbeHostNotIn        []string `json:"probehostNotIn,omitempty"`
	ProbeHostGT           *string  `json:"probehostGT,omitempty"`
	ProbeHostGTE          *string  `json:"probehostGTE,omitempty"`
	ProbeHostLT           *string  `json:"probehostLT,omitempty"`
	ProbeHostLTE          *string  `json:"probehostLTE,omitempty"`
	ProbeHostContains     *string  `json:"probehostContains,omitempty"`
	ProbeHostHasPrefix    *string  `json:"probehostHasPrefix,omitempty"`
	ProbeHostHasSuffix    *string  `json:"probehostHasSuffix,omitempty"`
	ProbeHostEqualFold    *string  `json:"probehostEqualFold,omitempty"`
	ProbeHostContainsFold *string  `json:"probehostContainsFold,omitempty"`

	// "Error" field predicates.
	Error             *string  `json:"error,omitempty"`
	ErrorNEQ          *string  `json:"errorNEQ,omitempty"`
	ErrorIn           []string `json:"errorIn,omitempty"`
	ErrorNotIn        []string `json:"errorNotIn,omitempty"`
	ErrorGT           *string  `json:"errorGT,omitempty"`
	ErrorGTE          *string  `json:"errorGTE,omitempty"`
	ErrorLT           *string  `json:"errorLT,omitempty"`
	ErrorLTE          *string  `json:"errorLTE,omitempty"`
	ErrorContains     *string  `json:"errorContains,omitempty"`
	ErrorHasPrefix    *string  `json:"errorHasPrefix,omitempty"`
	ErrorHasSuffix    *string  `json:"errorHasSuffix,omitempty"`
	ErrorIsNil        bool     `json:"errorIsNil,omitempty"`
	ErrorNotNil       bool     `json:"errorNotNil,omitempty"`
	ErrorEqualFold    *string  `json:"errorEqualFold,omitempty"`
	ErrorContainsFold *string  `json:"errorContainsFold,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *AlertWhereInput) AddPredicates(predicates ...predicate.Alert) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the AlertWhereInput filter on the AlertQuery builder.
func (i *AlertWhereInput) Filter(q *AlertQuery) (*AlertQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyAlertWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyAlertWhereInput is returned in case the AlertWhereInput is empty.
var ErrEmptyAlertWhereInput = errors.New("ent: empty predicate AlertWhereInput")

// P returns a predicate for filtering alerts.
// An error is returned if the input is empty or invalid.
func (i *AlertWhereInput) P() (predicate.Alert, error) {
	var predicates []predicate.Alert
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, alert.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Alert, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, alert.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Alert, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, alert.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, alert.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, alert.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, alert.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, alert.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, alert.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, alert.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, alert.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, alert.IDLTE(*i.IDLTE))
	}
	if i.Level != nil {
		predicates = append(predicates, alert.LevelEQ(*i.Level))
	}
	if i.LevelNEQ != nil {
		predicates = append(predicates, alert.LevelNEQ(*i.LevelNEQ))
	}
	if len(i.LevelIn) > 0 {
		predicates = append(predicates, alert.LevelIn(i.LevelIn...))
	}
	if len(i.LevelNotIn) > 0 {
		predicates = append(predicates, alert.LevelNotIn(i.LevelNotIn...))
	}
	if i.LevelGT != nil {
		predicates = append(predicates, alert.LevelGT(*i.LevelGT))
	}
	if i.LevelGTE != nil {
		predicates = append(predicates, alert.LevelGTE(*i.LevelGTE))
	}
	if i.LevelLT != nil {
		predicates = append(predicates, alert.LevelLT(*i.LevelLT))
	}
	if i.LevelLTE != nil {
		predicates = append(predicates, alert.LevelLTE(*i.LevelLTE))
	}
	if i.UUID != nil {
		predicates = append(predicates, alert.UUIDEQ(*i.UUID))
	}
	if i.UUIDNEQ != nil {
		predicates = append(predicates, alert.UUIDNEQ(*i.UUIDNEQ))
	}
	if len(i.UUIDIn) > 0 {
		predicates = append(predicates, alert.UUIDIn(i.UUIDIn...))
	}
	if len(i.UUIDNotIn) > 0 {
		predicates = append(predicates, alert.UUIDNotIn(i.UUIDNotIn...))
	}
	if i.UUIDGT != nil {
		predicates = append(predicates, alert.UUIDGT(*i.UUIDGT))
	}
	if i.UUIDGTE != nil {
		predicates = append(predicates, alert.UUIDGTE(*i.UUIDGTE))
	}
	if i.UUIDLT != nil {
		predicates = append(predicates, alert.UUIDLT(*i.UUIDLT))
	}
	if i.UUIDLTE != nil {
		predicates = append(predicates, alert.UUIDLTE(*i.UUIDLTE))
	}
	if i.IncidentID != nil {
		predicates = append(predicates, alert.IncidentIDEQ(*i.IncidentID))
	}
	if i.IncidentIDNEQ != nil {
		predicates = append(predicates, alert.IncidentIDNEQ(*i.IncidentIDNEQ))
	}
	if len(i.IncidentIDIn) > 0 {
		predicates = append(predicates, alert.IncidentIDIn(i.IncidentIDIn...))
	}
	if len(i.IncidentIDNotIn) > 0 {
		predicates = append(predicates, alert.IncidentIDNotIn(i.IncidentIDNotIn...))
	}
	if i.IncidentIDGT != nil {
		predicates = append(predicates, alert.IncidentIDGT(*i.IncidentIDGT))
	}
	if i.IncidentIDGTE != nil {
		predicates = append(predicates, alert.IncidentIDGTE(*i.IncidentIDGTE))
	}
	if i.IncidentIDLT != nil {
		predicates = append(predicates, alert.IncidentIDLT(*i.IncidentIDLT))
	}
	if i.IncidentIDLTE != nil {
		predicates = append(predicates, alert.IncidentIDLTE(*i.IncidentIDLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, alert.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, alert.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, alert.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, alert.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, alert.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, alert.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, alert.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, alert.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, alert.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, alert.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, alert.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, alert.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, alert.NameContainsFold(*i.NameContainsFold))
	}
	if i.Time != nil {
		predicates = append(predicates, alert.TimeEQ(*i.Time))
	}
	if i.TimeNEQ != nil {
		predicates = append(predicates, alert.TimeNEQ(*i.TimeNEQ))
	}
	if len(i.TimeIn) > 0 {
		predicates = append(predicates, alert.TimeIn(i.TimeIn...))
	}
	if len(i.TimeNotIn) > 0 {
		predicates = append(predicates, alert.TimeNotIn(i.TimeNotIn...))
	}
	if i.TimeGT != nil {
		predicates = append(predicates, alert.TimeGT(*i.TimeGT))
	}
	if i.TimeGTE != nil {
		predicates = append(predicates, alert.TimeGTE(*i.TimeGTE))
	}
	if i.TimeLT != nil {
		predicates = append(predicates, alert.TimeLT(*i.TimeLT))
	}
	if i.TimeLTE != nil {
		predicates = append(predicates, alert.TimeLTE(*i.TimeLTE))
	}
	if i.Username != nil {
		predicates = append(predicates, alert.UsernameEQ(*i.Username))
	}
	if i.UsernameNEQ != nil {
		predicates = append(predicates, alert.UsernameNEQ(*i.UsernameNEQ))
	}
	if len(i.UsernameIn) > 0 {
		predicates = append(predicates, alert.UsernameIn(i.UsernameIn...))
	}
	if len(i.UsernameNotIn) > 0 {
		predicates = append(predicates, alert.UsernameNotIn(i.UsernameNotIn...))
	}
	if i.UsernameGT != nil {
		predicates = append(predicates, alert.UsernameGT(*i.UsernameGT))
	}
	if i.UsernameGTE != nil {
		predicates = append(predicates, alert.UsernameGTE(*i.UsernameGTE))
	}
	if i.UsernameLT != nil {
		predicates = append(predicates, alert.UsernameLT(*i.UsernameLT))
	}
	if i.UsernameLTE != nil {
		predicates = append(predicates, alert.UsernameLTE(*i.UsernameLTE))
	}
	if i.UsernameContains != nil {
		predicates = append(predicates, alert.UsernameContains(*i.UsernameContains))
	}
	if i.UsernameHasPrefix != nil {
		predicates = append(predicates, alert.UsernameHasPrefix(*i.UsernameHasPrefix))
	}
	if i.UsernameHasSuffix != nil {
		predicates = append(predicates, alert.UsernameHasSuffix(*i.UsernameHasSuffix))
	}
	if i.UsernameEqualFold != nil {
		predicates = append(predicates, alert.UsernameEqualFold(*i.UsernameEqualFold))
	}
	if i.UsernameContainsFold != nil {
		predicates = append(predicates, alert.UsernameContainsFold(*i.UsernameContainsFold))
	}
	if i.Region != nil {
		predicates = append(predicates, alert.RegionEQ(*i.Region))
	}
	if i.RegionNEQ != nil {
		predicates = append(predicates, alert.RegionNEQ(*i.RegionNEQ))
	}
	if len(i.RegionIn) > 0 {
		predicates = append(predicates, alert.RegionIn(i.RegionIn...))
	}
	if len(i.RegionNotIn) > 0 {
		predicates = append(predicates, alert.RegionNotIn(i.RegionNotIn...))
	}
	if i.RegionGT != nil {
		predicates = append(predicates, alert.RegionGT(*i.RegionGT))
	}
	if i.RegionGTE != nil {
		predicates = append(predicates, alert.RegionGTE(*i.RegionGTE))
	}
	if i.RegionLT != nil {
		predicates = append(predicates, alert.RegionLT(*i.RegionLT))
	}
	if i.RegionLTE != nil {
		predicates = append(predicates, alert.RegionLTE(*i.RegionLTE))
	}
	if i.RegionContains != nil {
		predicates = append(predicates, alert.RegionContains(*i.RegionContains))
	}
	if i.RegionHasPrefix != nil {
		predicates = append(predicates, alert.RegionHasPrefix(*i.RegionHasPrefix))
	}
	if i.RegionHasSuffix != nil {
		predicates = append(predicates, alert.RegionHasSuffix(*i.RegionHasSuffix))
	}
	if i.RegionEqualFold != nil {
		predicates = append(predicates, alert.RegionEqualFold(*i.RegionEqualFold))
	}
	if i.RegionContainsFold != nil {
		predicates = append(predicates, alert.RegionContainsFold(*i.RegionContainsFold))
	}
	if i.ProbeOS != nil {
		predicates = append(predicates, alert.ProbeOSEQ(*i.ProbeOS))
	}
	if i.ProbeOSNEQ != nil {
		predicates = append(predicates, alert.ProbeOSNEQ(*i.ProbeOSNEQ))
	}
	if len(i.ProbeOSIn) > 0 {
		predicates = append(predicates, alert.ProbeOSIn(i.ProbeOSIn...))
	}
	if len(i.ProbeOSNotIn) > 0 {
		predicates = append(predicates, alert.ProbeOSNotIn(i.ProbeOSNotIn...))
	}
	if i.ProbeOSGT != nil {
		predicates = append(predicates, alert.ProbeOSGT(*i.ProbeOSGT))
	}
	if i.ProbeOSGTE != nil {
		predicates = append(predicates, alert.ProbeOSGTE(*i.ProbeOSGTE))
	}
	if i.ProbeOSLT != nil {
		predicates = append(predicates, alert.ProbeOSLT(*i.ProbeOSLT))
	}
	if i.ProbeOSLTE != nil {
		predicates = append(predicates, alert.ProbeOSLTE(*i.ProbeOSLTE))
	}
	if i.ProbeOSContains != nil {
		predicates = append(predicates, alert.ProbeOSContains(*i.ProbeOSContains))
	}
	if i.ProbeOSHasPrefix != nil {
		predicates = append(predicates, alert.ProbeOSHasPrefix(*i.ProbeOSHasPrefix))
	}
	if i.ProbeOSHasSuffix != nil {
		predicates = append(predicates, alert.ProbeOSHasSuffix(*i.ProbeOSHasSuffix))
	}
	if i.ProbeOSEqualFold != nil {
		predicates = append(predicates, alert.ProbeOSEqualFold(*i.ProbeOSEqualFold))
	}
	if i.ProbeOSContainsFold != nil {
		predicates = append(predicates, alert.ProbeOSContainsFold(*i.ProbeOSContainsFold))
	}
	if i.ProbeHost != nil {
		predicates = append(predicates, alert.ProbeHostEQ(*i.ProbeHost))
	}
	if i.ProbeHostNEQ != nil {
		predicates = append(predicates, alert.ProbeHostNEQ(*i.ProbeHostNEQ))
	}
	if len(i.ProbeHostIn) > 0 {
		predicates = append(predicates, alert.ProbeHostIn(i.ProbeHostIn...))
	}
	if len(i.ProbeHostNotIn) > 0 {
		predicates = append(predicates, alert.ProbeHostNotIn(i.ProbeHostNotIn...))
	}
	if i.ProbeHostGT != nil {
		predicates = append(predicates, alert.ProbeHostGT(*i.ProbeHostGT))
	}
	if i.ProbeHostGTE != nil {
		predicates = append(predicates, alert.ProbeHostGTE(*i.ProbeHostGTE))
	}
	if i.ProbeHostLT != nil {
		predicates = append(predicates, alert.ProbeHostLT(*i.ProbeHostLT))
	}
	if i.ProbeHostLTE != nil {
		predicates = append(predicates, alert.ProbeHostLTE(*i.ProbeHostLTE))
	}
	if i.ProbeHostContains != nil {
		predicates = append(predicates, alert.ProbeHostContains(*i.ProbeHostContains))
	}
	if i.ProbeHostHasPrefix != nil {
		predicates = append(predicates, alert.ProbeHostHasPrefix(*i.ProbeHostHasPrefix))
	}
	if i.ProbeHostHasSuffix != nil {
		predicates = append(predicates, alert.ProbeHostHasSuffix(*i.ProbeHostHasSuffix))
	}
	if i.ProbeHostEqualFold != nil {
		predicates = append(predicates, alert.ProbeHostEqualFold(*i.ProbeHostEqualFold))
	}
	if i.ProbeHostContainsFold != nil {
		predicates = append(predicates, alert.ProbeHostContainsFold(*i.ProbeHostContainsFold))
	}
	if i.Error != nil {
		predicates = append(predicates, alert.ErrorEQ(*i.Error))
	}
	if i.ErrorNEQ != nil {
		predicates = append(predicates, alert.ErrorNEQ(*i.ErrorNEQ))
	}
	if len(i.ErrorIn) > 0 {
		predicates = append(predicates, alert.ErrorIn(i.ErrorIn...))
	}
	if len(i.ErrorNotIn) > 0 {
		predicates = append(predicates, alert.ErrorNotIn(i.ErrorNotIn...))
	}
	if i.ErrorGT != nil {
		predicates = append(predicates, alert.ErrorGT(*i.ErrorGT))
	}
	if i.ErrorGTE != nil {
		predicates = append(predicates, alert.ErrorGTE(*i.ErrorGTE))
	}
	if i.ErrorLT != nil {
		predicates = append(predicates, alert.ErrorLT(*i.ErrorLT))
	}
	if i.ErrorLTE != nil {
		predicates = append(predicates, alert.ErrorLTE(*i.ErrorLTE))
	}
	if i.ErrorContains != nil {
		predicates = append(predicates, alert.ErrorContains(*i.ErrorContains))
	}
	if i.ErrorHasPrefix != nil {
		predicates = append(predicates, alert.ErrorHasPrefix(*i.ErrorHasPrefix))
	}
	if i.ErrorHasSuffix != nil {
		predicates = append(predicates, alert.ErrorHasSuffix(*i.ErrorHasSuffix))
	}
	if i.ErrorIsNil {
		predicates = append(predicates, alert.ErrorIsNil())
	}
	if i.ErrorNotNil {
		predicates = append(predicates, alert.ErrorNotNil())
	}
	if i.ErrorEqualFold != nil {
		predicates = append(predicates, alert.ErrorEqualFold(*i.ErrorEqualFold))
	}
	if i.ErrorContainsFold != nil {
		predicates = append(predicates, alert.ErrorContainsFold(*i.ErrorContainsFold))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyAlertWhereInput
	case 1:
		return predicates[0], nil
	default:
		return alert.And(predicates...), nil
	}
}

// CounterWhereInput represents a where input for filtering Counter queries.
type CounterWhereInput struct {
	Predicates []predicate.Counter  `json:"-"`
	Not        *CounterWhereInput   `json:"not,omitempty"`
	Or         []*CounterWhereInput `json:"or,omitempty"`
	And        []*CounterWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "Name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "Value" field predicates.
	Value             *string  `json:"value,omitempty"`
	ValueNEQ          *string  `json:"valueNEQ,omitempty"`
	ValueIn           []string `json:"valueIn,omitempty"`
	ValueNotIn        []string `json:"valueNotIn,omitempty"`
	ValueGT           *string  `json:"valueGT,omitempty"`
	ValueGTE          *string  `json:"valueGTE,omitempty"`
	ValueLT           *string  `json:"valueLT,omitempty"`
	ValueLTE          *string  `json:"valueLTE,omitempty"`
	ValueContains     *string  `json:"valueContains,omitempty"`
	ValueHasPrefix    *string  `json:"valueHasPrefix,omitempty"`
	ValueHasSuffix    *string  `json:"valueHasSuffix,omitempty"`
	ValueEqualFold    *string  `json:"valueEqualFold,omitempty"`
	ValueContainsFold *string  `json:"valueContainsFold,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *CounterWhereInput) AddPredicates(predicates ...predicate.Counter) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the CounterWhereInput filter on the CounterQuery builder.
func (i *CounterWhereInput) Filter(q *CounterQuery) (*CounterQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyCounterWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyCounterWhereInput is returned in case the CounterWhereInput is empty.
var ErrEmptyCounterWhereInput = errors.New("ent: empty predicate CounterWhereInput")

// P returns a predicate for filtering counters.
// An error is returned if the input is empty or invalid.
func (i *CounterWhereInput) P() (predicate.Counter, error) {
	var predicates []predicate.Counter
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, counter.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Counter, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, counter.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Counter, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, counter.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, counter.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, counter.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, counter.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, counter.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, counter.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, counter.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, counter.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, counter.IDLTE(*i.IDLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, counter.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, counter.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, counter.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, counter.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, counter.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, counter.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, counter.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, counter.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, counter.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, counter.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, counter.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, counter.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, counter.NameContainsFold(*i.NameContainsFold))
	}
	if i.Value != nil {
		predicates = append(predicates, counter.ValueEQ(*i.Value))
	}
	if i.ValueNEQ != nil {
		predicates = append(predicates, counter.ValueNEQ(*i.ValueNEQ))
	}
	if len(i.ValueIn) > 0 {
		predicates = append(predicates, counter.ValueIn(i.ValueIn...))
	}
	if len(i.ValueNotIn) > 0 {
		predicates = append(predicates, counter.ValueNotIn(i.ValueNotIn...))
	}
	if i.ValueGT != nil {
		predicates = append(predicates, counter.ValueGT(*i.ValueGT))
	}
	if i.ValueGTE != nil {
		predicates = append(predicates, counter.ValueGTE(*i.ValueGTE))
	}
	if i.ValueLT != nil {
		predicates = append(predicates, counter.ValueLT(*i.ValueLT))
	}
	if i.ValueLTE != nil {
		predicates = append(predicates, counter.ValueLTE(*i.ValueLTE))
	}
	if i.ValueContains != nil {
		predicates = append(predicates, counter.ValueContains(*i.ValueContains))
	}
	if i.ValueHasPrefix != nil {
		predicates = append(predicates, counter.ValueHasPrefix(*i.ValueHasPrefix))
	}
	if i.ValueHasSuffix != nil {
		predicates = append(predicates, counter.ValueHasSuffix(*i.ValueHasSuffix))
	}
	if i.ValueEqualFold != nil {
		predicates = append(predicates, counter.ValueEqualFold(*i.ValueEqualFold))
	}
	if i.ValueContainsFold != nil {
		predicates = append(predicates, counter.ValueContainsFold(*i.ValueContainsFold))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyCounterWhereInput
	case 1:
		return predicates[0], nil
	default:
		return counter.And(predicates...), nil
	}
}

// FailureWhereInput represents a where input for filtering Failure queries.
type FailureWhereInput struct {
	Predicates []predicate.Failure  `json:"-"`
	Not        *FailureWhereInput   `json:"not,omitempty"`
	Or         []*FailureWhereInput `json:"or,omitempty"`
	And        []*FailureWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "Error" field predicates.
	Error             *string  `json:"error,omitempty"`
	ErrorNEQ          *string  `json:"errorNEQ,omitempty"`
	ErrorIn           []string `json:"errorIn,omitempty"`
	ErrorNotIn        []string `json:"errorNotIn,omitempty"`
	ErrorGT           *string  `json:"errorGT,omitempty"`
	ErrorGTE          *string  `json:"errorGTE,omitempty"`
	ErrorLT           *string  `json:"errorLT,omitempty"`
	ErrorLTE          *string  `json:"errorLTE,omitempty"`
	ErrorContains     *string  `json:"errorContains,omitempty"`
	ErrorHasPrefix    *string  `json:"errorHasPrefix,omitempty"`
	ErrorHasSuffix    *string  `json:"errorHasSuffix,omitempty"`
	ErrorEqualFold    *string  `json:"errorEqualFold,omitempty"`
	ErrorContainsFold *string  `json:"errorContainsFold,omitempty"`

	// "Idx" field predicates.
	Idx      *int  `json:"idx,omitempty"`
	IdxNEQ   *int  `json:"idxNEQ,omitempty"`
	IdxIn    []int `json:"idxIn,omitempty"`
	IdxNotIn []int `json:"idxNotIn,omitempty"`
	IdxGT    *int  `json:"idxGT,omitempty"`
	IdxGTE   *int  `json:"idxGTE,omitempty"`
	IdxLT    *int  `json:"idxLT,omitempty"`
	IdxLTE   *int  `json:"idxLTE,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *FailureWhereInput) AddPredicates(predicates ...predicate.Failure) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the FailureWhereInput filter on the FailureQuery builder.
func (i *FailureWhereInput) Filter(q *FailureQuery) (*FailureQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyFailureWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyFailureWhereInput is returned in case the FailureWhereInput is empty.
var ErrEmptyFailureWhereInput = errors.New("ent: empty predicate FailureWhereInput")

// P returns a predicate for filtering failures.
// An error is returned if the input is empty or invalid.
func (i *FailureWhereInput) P() (predicate.Failure, error) {
	var predicates []predicate.Failure
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, failure.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Failure, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, failure.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Failure, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, failure.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, failure.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, failure.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, failure.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, failure.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, failure.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, failure.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, failure.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, failure.IDLTE(*i.IDLTE))
	}
	if i.Error != nil {
		predicates = append(predicates, failure.ErrorEQ(*i.Error))
	}
	if i.ErrorNEQ != nil {
		predicates = append(predicates, failure.ErrorNEQ(*i.ErrorNEQ))
	}
	if len(i.ErrorIn) > 0 {
		predicates = append(predicates, failure.ErrorIn(i.ErrorIn...))
	}
	if len(i.ErrorNotIn) > 0 {
		predicates = append(predicates, failure.ErrorNotIn(i.ErrorNotIn...))
	}
	if i.ErrorGT != nil {
		predicates = append(predicates, failure.ErrorGT(*i.ErrorGT))
	}
	if i.ErrorGTE != nil {
		predicates = append(predicates, failure.ErrorGTE(*i.ErrorGTE))
	}
	if i.ErrorLT != nil {
		predicates = append(predicates, failure.ErrorLT(*i.ErrorLT))
	}
	if i.ErrorLTE != nil {
		predicates = append(predicates, failure.ErrorLTE(*i.ErrorLTE))
	}
	if i.ErrorContains != nil {
		predicates = append(predicates, failure.ErrorContains(*i.ErrorContains))
	}
	if i.ErrorHasPrefix != nil {
		predicates = append(predicates, failure.ErrorHasPrefix(*i.ErrorHasPrefix))
	}
	if i.ErrorHasSuffix != nil {
		predicates = append(predicates, failure.ErrorHasSuffix(*i.ErrorHasSuffix))
	}
	if i.ErrorEqualFold != nil {
		predicates = append(predicates, failure.ErrorEqualFold(*i.ErrorEqualFold))
	}
	if i.ErrorContainsFold != nil {
		predicates = append(predicates, failure.ErrorContainsFold(*i.ErrorContainsFold))
	}
	if i.Idx != nil {
		predicates = append(predicates, failure.IdxEQ(*i.Idx))
	}
	if i.IdxNEQ != nil {
		predicates = append(predicates, failure.IdxNEQ(*i.IdxNEQ))
	}
	if len(i.IdxIn) > 0 {
		predicates = append(predicates, failure.IdxIn(i.IdxIn...))
	}
	if len(i.IdxNotIn) > 0 {
		predicates = append(predicates, failure.IdxNotIn(i.IdxNotIn...))
	}
	if i.IdxGT != nil {
		predicates = append(predicates, failure.IdxGT(*i.IdxGT))
	}
	if i.IdxGTE != nil {
		predicates = append(predicates, failure.IdxGTE(*i.IdxGTE))
	}
	if i.IdxLT != nil {
		predicates = append(predicates, failure.IdxLT(*i.IdxLT))
	}
	if i.IdxLTE != nil {
		predicates = append(predicates, failure.IdxLTE(*i.IdxLTE))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyFailureWhereInput
	case 1:
		return predicates[0], nil
	default:
		return failure.And(predicates...), nil
	}
}

// IncidentWhereInput represents a where input for filtering Incident queries.
type IncidentWhereInput struct {
	Predicates []predicate.Incident  `json:"-"`
	Not        *IncidentWhereInput   `json:"not,omitempty"`
	Or         []*IncidentWhereInput `json:"or,omitempty"`
	And        []*IncidentWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "Level" field predicates.
	Level       *int  `json:"level,omitempty"`
	LevelNEQ    *int  `json:"levelNEQ,omitempty"`
	LevelIn     []int `json:"levelIn,omitempty"`
	LevelNotIn  []int `json:"levelNotIn,omitempty"`
	LevelGT     *int  `json:"levelGT,omitempty"`
	LevelGTE    *int  `json:"levelGTE,omitempty"`
	LevelLT     *int  `json:"levelLT,omitempty"`
	LevelLTE    *int  `json:"levelLTE,omitempty"`
	LevelIsNil  bool  `json:"levelIsNil,omitempty"`
	LevelNotNil bool  `json:"levelNotNil,omitempty"`

	// "Start" field predicates.
	Start      *time.Time  `json:"start,omitempty"`
	StartNEQ   *time.Time  `json:"startNEQ,omitempty"`
	StartIn    []time.Time `json:"startIn,omitempty"`
	StartNotIn []time.Time `json:"startNotIn,omitempty"`
	StartGT    *time.Time  `json:"startGT,omitempty"`
	StartGTE   *time.Time  `json:"startGTE,omitempty"`
	StartLT    *time.Time  `json:"startLT,omitempty"`
	StartLTE   *time.Time  `json:"startLTE,omitempty"`

	// "End" field predicates.
	End      *time.Time  `json:"end,omitempty"`
	EndNEQ   *time.Time  `json:"endNEQ,omitempty"`
	EndIn    []time.Time `json:"endIn,omitempty"`
	EndNotIn []time.Time `json:"endNotIn,omitempty"`
	EndGT    *time.Time  `json:"endGT,omitempty"`
	EndGTE   *time.Time  `json:"endGTE,omitempty"`
	EndLT    *time.Time  `json:"endLT,omitempty"`
	EndLTE   *time.Time  `json:"endLTE,omitempty"`

	// "UUID" field predicates.
	UUID      *uuid.UUID  `json:"uuid,omitempty"`
	UUIDNEQ   *uuid.UUID  `json:"uuidNEQ,omitempty"`
	UUIDIn    []uuid.UUID `json:"uuidIn,omitempty"`
	UUIDNotIn []uuid.UUID `json:"uuidNotIn,omitempty"`
	UUIDGT    *uuid.UUID  `json:"uuidGT,omitempty"`
	UUIDGTE   *uuid.UUID  `json:"uuidGTE,omitempty"`
	UUIDLT    *uuid.UUID  `json:"uuidLT,omitempty"`
	UUIDLTE   *uuid.UUID  `json:"uuidLTE,omitempty"`

	// "IncidentID" field predicates.
	IncidentID      *uuid.UUID  `json:"incidentid,omitempty"`
	IncidentIDNEQ   *uuid.UUID  `json:"incidentidNEQ,omitempty"`
	IncidentIDIn    []uuid.UUID `json:"incidentidIn,omitempty"`
	IncidentIDNotIn []uuid.UUID `json:"incidentidNotIn,omitempty"`
	IncidentIDGT    *uuid.UUID  `json:"incidentidGT,omitempty"`
	IncidentIDGTE   *uuid.UUID  `json:"incidentidGTE,omitempty"`
	IncidentIDLT    *uuid.UUID  `json:"incidentidLT,omitempty"`
	IncidentIDLTE   *uuid.UUID  `json:"incidentidLTE,omitempty"`

	// "Name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "Time" field predicates.
	Time      *time.Time  `json:"time,omitempty"`
	TimeNEQ   *time.Time  `json:"timeNEQ,omitempty"`
	TimeIn    []time.Time `json:"timeIn,omitempty"`
	TimeNotIn []time.Time `json:"timeNotIn,omitempty"`
	TimeGT    *time.Time  `json:"timeGT,omitempty"`
	TimeGTE   *time.Time  `json:"timeGTE,omitempty"`
	TimeLT    *time.Time  `json:"timeLT,omitempty"`
	TimeLTE   *time.Time  `json:"timeLTE,omitempty"`

	// "Username" field predicates.
	Username             *string  `json:"username,omitempty"`
	UsernameNEQ          *string  `json:"usernameNEQ,omitempty"`
	UsernameIn           []string `json:"usernameIn,omitempty"`
	UsernameNotIn        []string `json:"usernameNotIn,omitempty"`
	UsernameGT           *string  `json:"usernameGT,omitempty"`
	UsernameGTE          *string  `json:"usernameGTE,omitempty"`
	UsernameLT           *string  `json:"usernameLT,omitempty"`
	UsernameLTE          *string  `json:"usernameLTE,omitempty"`
	UsernameContains     *string  `json:"usernameContains,omitempty"`
	UsernameHasPrefix    *string  `json:"usernameHasPrefix,omitempty"`
	UsernameHasSuffix    *string  `json:"usernameHasSuffix,omitempty"`
	UsernameEqualFold    *string  `json:"usernameEqualFold,omitempty"`
	UsernameContainsFold *string  `json:"usernameContainsFold,omitempty"`

	// "Region" field predicates.
	Region             *string  `json:"region,omitempty"`
	RegionNEQ          *string  `json:"regionNEQ,omitempty"`
	RegionIn           []string `json:"regionIn,omitempty"`
	RegionNotIn        []string `json:"regionNotIn,omitempty"`
	RegionGT           *string  `json:"regionGT,omitempty"`
	RegionGTE          *string  `json:"regionGTE,omitempty"`
	RegionLT           *string  `json:"regionLT,omitempty"`
	RegionLTE          *string  `json:"regionLTE,omitempty"`
	RegionContains     *string  `json:"regionContains,omitempty"`
	RegionHasPrefix    *string  `json:"regionHasPrefix,omitempty"`
	RegionHasSuffix    *string  `json:"regionHasSuffix,omitempty"`
	RegionEqualFold    *string  `json:"regionEqualFold,omitempty"`
	RegionContainsFold *string  `json:"regionContainsFold,omitempty"`

	// "ProbeOS" field predicates.
	ProbeOS             *string  `json:"probeos,omitempty"`
	ProbeOSNEQ          *string  `json:"probeosNEQ,omitempty"`
	ProbeOSIn           []string `json:"probeosIn,omitempty"`
	ProbeOSNotIn        []string `json:"probeosNotIn,omitempty"`
	ProbeOSGT           *string  `json:"probeosGT,omitempty"`
	ProbeOSGTE          *string  `json:"probeosGTE,omitempty"`
	ProbeOSLT           *string  `json:"probeosLT,omitempty"`
	ProbeOSLTE          *string  `json:"probeosLTE,omitempty"`
	ProbeOSContains     *string  `json:"probeosContains,omitempty"`
	ProbeOSHasPrefix    *string  `json:"probeosHasPrefix,omitempty"`
	ProbeOSHasSuffix    *string  `json:"probeosHasSuffix,omitempty"`
	ProbeOSEqualFold    *string  `json:"probeosEqualFold,omitempty"`
	ProbeOSContainsFold *string  `json:"probeosContainsFold,omitempty"`

	// "ProbeHost" field predicates.
	ProbeHost             *string  `json:"probehost,omitempty"`
	ProbeHostNEQ          *string  `json:"probehostNEQ,omitempty"`
	ProbeHostIn           []string `json:"probehostIn,omitempty"`
	ProbeHostNotIn        []string `json:"probehostNotIn,omitempty"`
	ProbeHostGT           *string  `json:"probehostGT,omitempty"`
	ProbeHostGTE          *string  `json:"probehostGTE,omitempty"`
	ProbeHostLT           *string  `json:"probehostLT,omitempty"`
	ProbeHostLTE          *string  `json:"probehostLTE,omitempty"`
	ProbeHostContains     *string  `json:"probehostContains,omitempty"`
	ProbeHostHasPrefix    *string  `json:"probehostHasPrefix,omitempty"`
	ProbeHostHasSuffix    *string  `json:"probehostHasSuffix,omitempty"`
	ProbeHostEqualFold    *string  `json:"probehostEqualFold,omitempty"`
	ProbeHostContainsFold *string  `json:"probehostContainsFold,omitempty"`

	// "Error" field predicates.
	Error             *string  `json:"error,omitempty"`
	ErrorNEQ          *string  `json:"errorNEQ,omitempty"`
	ErrorIn           []string `json:"errorIn,omitempty"`
	ErrorNotIn        []string `json:"errorNotIn,omitempty"`
	ErrorGT           *string  `json:"errorGT,omitempty"`
	ErrorGTE          *string  `json:"errorGTE,omitempty"`
	ErrorLT           *string  `json:"errorLT,omitempty"`
	ErrorLTE          *string  `json:"errorLTE,omitempty"`
	ErrorContains     *string  `json:"errorContains,omitempty"`
	ErrorHasPrefix    *string  `json:"errorHasPrefix,omitempty"`
	ErrorHasSuffix    *string  `json:"errorHasSuffix,omitempty"`
	ErrorIsNil        bool     `json:"errorIsNil,omitempty"`
	ErrorNotNil       bool     `json:"errorNotNil,omitempty"`
	ErrorEqualFold    *string  `json:"errorEqualFold,omitempty"`
	ErrorContainsFold *string  `json:"errorContainsFold,omitempty"`

	// "Counters" edge predicates.
	HasCounters     *bool                `json:"hasCounters,omitempty"`
	HasCountersWith []*CounterWhereInput `json:"hasCountersWith,omitempty"`

	// "Stati" edge predicates.
	HasStati     *bool               `json:"hasStati,omitempty"`
	HasStatiWith []*StatusWhereInput `json:"hasStatiWith,omitempty"`

	// "Failures" edge predicates.
	HasFailures     *bool                `json:"hasFailures,omitempty"`
	HasFailuresWith []*FailureWhereInput `json:"hasFailuresWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *IncidentWhereInput) AddPredicates(predicates ...predicate.Incident) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the IncidentWhereInput filter on the IncidentQuery builder.
func (i *IncidentWhereInput) Filter(q *IncidentQuery) (*IncidentQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyIncidentWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyIncidentWhereInput is returned in case the IncidentWhereInput is empty.
var ErrEmptyIncidentWhereInput = errors.New("ent: empty predicate IncidentWhereInput")

// P returns a predicate for filtering incidents.
// An error is returned if the input is empty or invalid.
func (i *IncidentWhereInput) P() (predicate.Incident, error) {
	var predicates []predicate.Incident
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, incident.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Incident, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, incident.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Incident, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, incident.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, incident.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, incident.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, incident.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, incident.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, incident.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, incident.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, incident.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, incident.IDLTE(*i.IDLTE))
	}
	if i.Level != nil {
		predicates = append(predicates, incident.LevelEQ(*i.Level))
	}
	if i.LevelNEQ != nil {
		predicates = append(predicates, incident.LevelNEQ(*i.LevelNEQ))
	}
	if len(i.LevelIn) > 0 {
		predicates = append(predicates, incident.LevelIn(i.LevelIn...))
	}
	if len(i.LevelNotIn) > 0 {
		predicates = append(predicates, incident.LevelNotIn(i.LevelNotIn...))
	}
	if i.LevelGT != nil {
		predicates = append(predicates, incident.LevelGT(*i.LevelGT))
	}
	if i.LevelGTE != nil {
		predicates = append(predicates, incident.LevelGTE(*i.LevelGTE))
	}
	if i.LevelLT != nil {
		predicates = append(predicates, incident.LevelLT(*i.LevelLT))
	}
	if i.LevelLTE != nil {
		predicates = append(predicates, incident.LevelLTE(*i.LevelLTE))
	}
	if i.LevelIsNil {
		predicates = append(predicates, incident.LevelIsNil())
	}
	if i.LevelNotNil {
		predicates = append(predicates, incident.LevelNotNil())
	}
	if i.Start != nil {
		predicates = append(predicates, incident.StartEQ(*i.Start))
	}
	if i.StartNEQ != nil {
		predicates = append(predicates, incident.StartNEQ(*i.StartNEQ))
	}
	if len(i.StartIn) > 0 {
		predicates = append(predicates, incident.StartIn(i.StartIn...))
	}
	if len(i.StartNotIn) > 0 {
		predicates = append(predicates, incident.StartNotIn(i.StartNotIn...))
	}
	if i.StartGT != nil {
		predicates = append(predicates, incident.StartGT(*i.StartGT))
	}
	if i.StartGTE != nil {
		predicates = append(predicates, incident.StartGTE(*i.StartGTE))
	}
	if i.StartLT != nil {
		predicates = append(predicates, incident.StartLT(*i.StartLT))
	}
	if i.StartLTE != nil {
		predicates = append(predicates, incident.StartLTE(*i.StartLTE))
	}
	if i.End != nil {
		predicates = append(predicates, incident.EndEQ(*i.End))
	}
	if i.EndNEQ != nil {
		predicates = append(predicates, incident.EndNEQ(*i.EndNEQ))
	}
	if len(i.EndIn) > 0 {
		predicates = append(predicates, incident.EndIn(i.EndIn...))
	}
	if len(i.EndNotIn) > 0 {
		predicates = append(predicates, incident.EndNotIn(i.EndNotIn...))
	}
	if i.EndGT != nil {
		predicates = append(predicates, incident.EndGT(*i.EndGT))
	}
	if i.EndGTE != nil {
		predicates = append(predicates, incident.EndGTE(*i.EndGTE))
	}
	if i.EndLT != nil {
		predicates = append(predicates, incident.EndLT(*i.EndLT))
	}
	if i.EndLTE != nil {
		predicates = append(predicates, incident.EndLTE(*i.EndLTE))
	}
	if i.UUID != nil {
		predicates = append(predicates, incident.UUIDEQ(*i.UUID))
	}
	if i.UUIDNEQ != nil {
		predicates = append(predicates, incident.UUIDNEQ(*i.UUIDNEQ))
	}
	if len(i.UUIDIn) > 0 {
		predicates = append(predicates, incident.UUIDIn(i.UUIDIn...))
	}
	if len(i.UUIDNotIn) > 0 {
		predicates = append(predicates, incident.UUIDNotIn(i.UUIDNotIn...))
	}
	if i.UUIDGT != nil {
		predicates = append(predicates, incident.UUIDGT(*i.UUIDGT))
	}
	if i.UUIDGTE != nil {
		predicates = append(predicates, incident.UUIDGTE(*i.UUIDGTE))
	}
	if i.UUIDLT != nil {
		predicates = append(predicates, incident.UUIDLT(*i.UUIDLT))
	}
	if i.UUIDLTE != nil {
		predicates = append(predicates, incident.UUIDLTE(*i.UUIDLTE))
	}
	if i.IncidentID != nil {
		predicates = append(predicates, incident.IncidentIDEQ(*i.IncidentID))
	}
	if i.IncidentIDNEQ != nil {
		predicates = append(predicates, incident.IncidentIDNEQ(*i.IncidentIDNEQ))
	}
	if len(i.IncidentIDIn) > 0 {
		predicates = append(predicates, incident.IncidentIDIn(i.IncidentIDIn...))
	}
	if len(i.IncidentIDNotIn) > 0 {
		predicates = append(predicates, incident.IncidentIDNotIn(i.IncidentIDNotIn...))
	}
	if i.IncidentIDGT != nil {
		predicates = append(predicates, incident.IncidentIDGT(*i.IncidentIDGT))
	}
	if i.IncidentIDGTE != nil {
		predicates = append(predicates, incident.IncidentIDGTE(*i.IncidentIDGTE))
	}
	if i.IncidentIDLT != nil {
		predicates = append(predicates, incident.IncidentIDLT(*i.IncidentIDLT))
	}
	if i.IncidentIDLTE != nil {
		predicates = append(predicates, incident.IncidentIDLTE(*i.IncidentIDLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, incident.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, incident.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, incident.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, incident.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, incident.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, incident.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, incident.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, incident.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, incident.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, incident.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, incident.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, incident.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, incident.NameContainsFold(*i.NameContainsFold))
	}
	if i.Time != nil {
		predicates = append(predicates, incident.TimeEQ(*i.Time))
	}
	if i.TimeNEQ != nil {
		predicates = append(predicates, incident.TimeNEQ(*i.TimeNEQ))
	}
	if len(i.TimeIn) > 0 {
		predicates = append(predicates, incident.TimeIn(i.TimeIn...))
	}
	if len(i.TimeNotIn) > 0 {
		predicates = append(predicates, incident.TimeNotIn(i.TimeNotIn...))
	}
	if i.TimeGT != nil {
		predicates = append(predicates, incident.TimeGT(*i.TimeGT))
	}
	if i.TimeGTE != nil {
		predicates = append(predicates, incident.TimeGTE(*i.TimeGTE))
	}
	if i.TimeLT != nil {
		predicates = append(predicates, incident.TimeLT(*i.TimeLT))
	}
	if i.TimeLTE != nil {
		predicates = append(predicates, incident.TimeLTE(*i.TimeLTE))
	}
	if i.Username != nil {
		predicates = append(predicates, incident.UsernameEQ(*i.Username))
	}
	if i.UsernameNEQ != nil {
		predicates = append(predicates, incident.UsernameNEQ(*i.UsernameNEQ))
	}
	if len(i.UsernameIn) > 0 {
		predicates = append(predicates, incident.UsernameIn(i.UsernameIn...))
	}
	if len(i.UsernameNotIn) > 0 {
		predicates = append(predicates, incident.UsernameNotIn(i.UsernameNotIn...))
	}
	if i.UsernameGT != nil {
		predicates = append(predicates, incident.UsernameGT(*i.UsernameGT))
	}
	if i.UsernameGTE != nil {
		predicates = append(predicates, incident.UsernameGTE(*i.UsernameGTE))
	}
	if i.UsernameLT != nil {
		predicates = append(predicates, incident.UsernameLT(*i.UsernameLT))
	}
	if i.UsernameLTE != nil {
		predicates = append(predicates, incident.UsernameLTE(*i.UsernameLTE))
	}
	if i.UsernameContains != nil {
		predicates = append(predicates, incident.UsernameContains(*i.UsernameContains))
	}
	if i.UsernameHasPrefix != nil {
		predicates = append(predicates, incident.UsernameHasPrefix(*i.UsernameHasPrefix))
	}
	if i.UsernameHasSuffix != nil {
		predicates = append(predicates, incident.UsernameHasSuffix(*i.UsernameHasSuffix))
	}
	if i.UsernameEqualFold != nil {
		predicates = append(predicates, incident.UsernameEqualFold(*i.UsernameEqualFold))
	}
	if i.UsernameContainsFold != nil {
		predicates = append(predicates, incident.UsernameContainsFold(*i.UsernameContainsFold))
	}
	if i.Region != nil {
		predicates = append(predicates, incident.RegionEQ(*i.Region))
	}
	if i.RegionNEQ != nil {
		predicates = append(predicates, incident.RegionNEQ(*i.RegionNEQ))
	}
	if len(i.RegionIn) > 0 {
		predicates = append(predicates, incident.RegionIn(i.RegionIn...))
	}
	if len(i.RegionNotIn) > 0 {
		predicates = append(predicates, incident.RegionNotIn(i.RegionNotIn...))
	}
	if i.RegionGT != nil {
		predicates = append(predicates, incident.RegionGT(*i.RegionGT))
	}
	if i.RegionGTE != nil {
		predicates = append(predicates, incident.RegionGTE(*i.RegionGTE))
	}
	if i.RegionLT != nil {
		predicates = append(predicates, incident.RegionLT(*i.RegionLT))
	}
	if i.RegionLTE != nil {
		predicates = append(predicates, incident.RegionLTE(*i.RegionLTE))
	}
	if i.RegionContains != nil {
		predicates = append(predicates, incident.RegionContains(*i.RegionContains))
	}
	if i.RegionHasPrefix != nil {
		predicates = append(predicates, incident.RegionHasPrefix(*i.RegionHasPrefix))
	}
	if i.RegionHasSuffix != nil {
		predicates = append(predicates, incident.RegionHasSuffix(*i.RegionHasSuffix))
	}
	if i.RegionEqualFold != nil {
		predicates = append(predicates, incident.RegionEqualFold(*i.RegionEqualFold))
	}
	if i.RegionContainsFold != nil {
		predicates = append(predicates, incident.RegionContainsFold(*i.RegionContainsFold))
	}
	if i.ProbeOS != nil {
		predicates = append(predicates, incident.ProbeOSEQ(*i.ProbeOS))
	}
	if i.ProbeOSNEQ != nil {
		predicates = append(predicates, incident.ProbeOSNEQ(*i.ProbeOSNEQ))
	}
	if len(i.ProbeOSIn) > 0 {
		predicates = append(predicates, incident.ProbeOSIn(i.ProbeOSIn...))
	}
	if len(i.ProbeOSNotIn) > 0 {
		predicates = append(predicates, incident.ProbeOSNotIn(i.ProbeOSNotIn...))
	}
	if i.ProbeOSGT != nil {
		predicates = append(predicates, incident.ProbeOSGT(*i.ProbeOSGT))
	}
	if i.ProbeOSGTE != nil {
		predicates = append(predicates, incident.ProbeOSGTE(*i.ProbeOSGTE))
	}
	if i.ProbeOSLT != nil {
		predicates = append(predicates, incident.ProbeOSLT(*i.ProbeOSLT))
	}
	if i.ProbeOSLTE != nil {
		predicates = append(predicates, incident.ProbeOSLTE(*i.ProbeOSLTE))
	}
	if i.ProbeOSContains != nil {
		predicates = append(predicates, incident.ProbeOSContains(*i.ProbeOSContains))
	}
	if i.ProbeOSHasPrefix != nil {
		predicates = append(predicates, incident.ProbeOSHasPrefix(*i.ProbeOSHasPrefix))
	}
	if i.ProbeOSHasSuffix != nil {
		predicates = append(predicates, incident.ProbeOSHasSuffix(*i.ProbeOSHasSuffix))
	}
	if i.ProbeOSEqualFold != nil {
		predicates = append(predicates, incident.ProbeOSEqualFold(*i.ProbeOSEqualFold))
	}
	if i.ProbeOSContainsFold != nil {
		predicates = append(predicates, incident.ProbeOSContainsFold(*i.ProbeOSContainsFold))
	}
	if i.ProbeHost != nil {
		predicates = append(predicates, incident.ProbeHostEQ(*i.ProbeHost))
	}
	if i.ProbeHostNEQ != nil {
		predicates = append(predicates, incident.ProbeHostNEQ(*i.ProbeHostNEQ))
	}
	if len(i.ProbeHostIn) > 0 {
		predicates = append(predicates, incident.ProbeHostIn(i.ProbeHostIn...))
	}
	if len(i.ProbeHostNotIn) > 0 {
		predicates = append(predicates, incident.ProbeHostNotIn(i.ProbeHostNotIn...))
	}
	if i.ProbeHostGT != nil {
		predicates = append(predicates, incident.ProbeHostGT(*i.ProbeHostGT))
	}
	if i.ProbeHostGTE != nil {
		predicates = append(predicates, incident.ProbeHostGTE(*i.ProbeHostGTE))
	}
	if i.ProbeHostLT != nil {
		predicates = append(predicates, incident.ProbeHostLT(*i.ProbeHostLT))
	}
	if i.ProbeHostLTE != nil {
		predicates = append(predicates, incident.ProbeHostLTE(*i.ProbeHostLTE))
	}
	if i.ProbeHostContains != nil {
		predicates = append(predicates, incident.ProbeHostContains(*i.ProbeHostContains))
	}
	if i.ProbeHostHasPrefix != nil {
		predicates = append(predicates, incident.ProbeHostHasPrefix(*i.ProbeHostHasPrefix))
	}
	if i.ProbeHostHasSuffix != nil {
		predicates = append(predicates, incident.ProbeHostHasSuffix(*i.ProbeHostHasSuffix))
	}
	if i.ProbeHostEqualFold != nil {
		predicates = append(predicates, incident.ProbeHostEqualFold(*i.ProbeHostEqualFold))
	}
	if i.ProbeHostContainsFold != nil {
		predicates = append(predicates, incident.ProbeHostContainsFold(*i.ProbeHostContainsFold))
	}
	if i.Error != nil {
		predicates = append(predicates, incident.ErrorEQ(*i.Error))
	}
	if i.ErrorNEQ != nil {
		predicates = append(predicates, incident.ErrorNEQ(*i.ErrorNEQ))
	}
	if len(i.ErrorIn) > 0 {
		predicates = append(predicates, incident.ErrorIn(i.ErrorIn...))
	}
	if len(i.ErrorNotIn) > 0 {
		predicates = append(predicates, incident.ErrorNotIn(i.ErrorNotIn...))
	}
	if i.ErrorGT != nil {
		predicates = append(predicates, incident.ErrorGT(*i.ErrorGT))
	}
	if i.ErrorGTE != nil {
		predicates = append(predicates, incident.ErrorGTE(*i.ErrorGTE))
	}
	if i.ErrorLT != nil {
		predicates = append(predicates, incident.ErrorLT(*i.ErrorLT))
	}
	if i.ErrorLTE != nil {
		predicates = append(predicates, incident.ErrorLTE(*i.ErrorLTE))
	}
	if i.ErrorContains != nil {
		predicates = append(predicates, incident.ErrorContains(*i.ErrorContains))
	}
	if i.ErrorHasPrefix != nil {
		predicates = append(predicates, incident.ErrorHasPrefix(*i.ErrorHasPrefix))
	}
	if i.ErrorHasSuffix != nil {
		predicates = append(predicates, incident.ErrorHasSuffix(*i.ErrorHasSuffix))
	}
	if i.ErrorIsNil {
		predicates = append(predicates, incident.ErrorIsNil())
	}
	if i.ErrorNotNil {
		predicates = append(predicates, incident.ErrorNotNil())
	}
	if i.ErrorEqualFold != nil {
		predicates = append(predicates, incident.ErrorEqualFold(*i.ErrorEqualFold))
	}
	if i.ErrorContainsFold != nil {
		predicates = append(predicates, incident.ErrorContainsFold(*i.ErrorContainsFold))
	}

	if i.HasCounters != nil {
		p := incident.HasCounters()
		if !*i.HasCounters {
			p = incident.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCountersWith) > 0 {
		with := make([]predicate.Counter, 0, len(i.HasCountersWith))
		for _, w := range i.HasCountersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCountersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, incident.HasCountersWith(with...))
	}
	if i.HasStati != nil {
		p := incident.HasStati()
		if !*i.HasStati {
			p = incident.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasStatiWith) > 0 {
		with := make([]predicate.Status, 0, len(i.HasStatiWith))
		for _, w := range i.HasStatiWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasStatiWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, incident.HasStatiWith(with...))
	}
	if i.HasFailures != nil {
		p := incident.HasFailures()
		if !*i.HasFailures {
			p = incident.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasFailuresWith) > 0 {
		with := make([]predicate.Failure, 0, len(i.HasFailuresWith))
		for _, w := range i.HasFailuresWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasFailuresWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, incident.HasFailuresWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyIncidentWhereInput
	case 1:
		return predicates[0], nil
	default:
		return incident.And(predicates...), nil
	}
}

// StatusWhereInput represents a where input for filtering Status queries.
type StatusWhereInput struct {
	Predicates []predicate.Status  `json:"-"`
	Not        *StatusWhereInput   `json:"not,omitempty"`
	Or         []*StatusWhereInput `json:"or,omitempty"`
	And        []*StatusWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "Name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "Value" field predicates.
	Value             *string  `json:"value,omitempty"`
	ValueNEQ          *string  `json:"valueNEQ,omitempty"`
	ValueIn           []string `json:"valueIn,omitempty"`
	ValueNotIn        []string `json:"valueNotIn,omitempty"`
	ValueGT           *string  `json:"valueGT,omitempty"`
	ValueGTE          *string  `json:"valueGTE,omitempty"`
	ValueLT           *string  `json:"valueLT,omitempty"`
	ValueLTE          *string  `json:"valueLTE,omitempty"`
	ValueContains     *string  `json:"valueContains,omitempty"`
	ValueHasPrefix    *string  `json:"valueHasPrefix,omitempty"`
	ValueHasSuffix    *string  `json:"valueHasSuffix,omitempty"`
	ValueEqualFold    *string  `json:"valueEqualFold,omitempty"`
	ValueContainsFold *string  `json:"valueContainsFold,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *StatusWhereInput) AddPredicates(predicates ...predicate.Status) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the StatusWhereInput filter on the StatusQuery builder.
func (i *StatusWhereInput) Filter(q *StatusQuery) (*StatusQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyStatusWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyStatusWhereInput is returned in case the StatusWhereInput is empty.
var ErrEmptyStatusWhereInput = errors.New("ent: empty predicate StatusWhereInput")

// P returns a predicate for filtering statusslice.
// An error is returned if the input is empty or invalid.
func (i *StatusWhereInput) P() (predicate.Status, error) {
	var predicates []predicate.Status
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, status.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Status, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, status.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Status, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, status.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, status.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, status.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, status.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, status.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, status.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, status.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, status.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, status.IDLTE(*i.IDLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, status.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, status.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, status.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, status.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, status.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, status.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, status.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, status.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, status.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, status.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, status.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, status.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, status.NameContainsFold(*i.NameContainsFold))
	}
	if i.Value != nil {
		predicates = append(predicates, status.ValueEQ(*i.Value))
	}
	if i.ValueNEQ != nil {
		predicates = append(predicates, status.ValueNEQ(*i.ValueNEQ))
	}
	if len(i.ValueIn) > 0 {
		predicates = append(predicates, status.ValueIn(i.ValueIn...))
	}
	if len(i.ValueNotIn) > 0 {
		predicates = append(predicates, status.ValueNotIn(i.ValueNotIn...))
	}
	if i.ValueGT != nil {
		predicates = append(predicates, status.ValueGT(*i.ValueGT))
	}
	if i.ValueGTE != nil {
		predicates = append(predicates, status.ValueGTE(*i.ValueGTE))
	}
	if i.ValueLT != nil {
		predicates = append(predicates, status.ValueLT(*i.ValueLT))
	}
	if i.ValueLTE != nil {
		predicates = append(predicates, status.ValueLTE(*i.ValueLTE))
	}
	if i.ValueContains != nil {
		predicates = append(predicates, status.ValueContains(*i.ValueContains))
	}
	if i.ValueHasPrefix != nil {
		predicates = append(predicates, status.ValueHasPrefix(*i.ValueHasPrefix))
	}
	if i.ValueHasSuffix != nil {
		predicates = append(predicates, status.ValueHasSuffix(*i.ValueHasSuffix))
	}
	if i.ValueEqualFold != nil {
		predicates = append(predicates, status.ValueEqualFold(*i.ValueEqualFold))
	}
	if i.ValueContainsFold != nil {
		predicates = append(predicates, status.ValueContainsFold(*i.ValueContainsFold))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyStatusWhereInput
	case 1:
		return predicates[0], nil
	default:
		return status.And(predicates...), nil
	}
}
