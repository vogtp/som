// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"encoding/base64"
	"errors"
	"fmt"
	"io"
	"strconv"
	"strings"

	"entgo.io/ent/dialect/sql"
	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/errcode"
	"github.com/vektah/gqlparser/v2/gqlerror"
	"github.com/vmihailenco/msgpack/v5"
	"github.com/vogtp/som/pkg/visualiser/webstatus/ent/ent/alert"
	"github.com/vogtp/som/pkg/visualiser/webstatus/ent/ent/counter"
	"github.com/vogtp/som/pkg/visualiser/webstatus/ent/ent/failure"
	"github.com/vogtp/som/pkg/visualiser/webstatus/ent/ent/file"
	"github.com/vogtp/som/pkg/visualiser/webstatus/ent/ent/incident"
	"github.com/vogtp/som/pkg/visualiser/webstatus/ent/ent/status"
)

// OrderDirection defines the directions in which to order a list of items.
type OrderDirection string

const (
	// OrderDirectionAsc specifies an ascending order.
	OrderDirectionAsc OrderDirection = "ASC"
	// OrderDirectionDesc specifies a descending order.
	OrderDirectionDesc OrderDirection = "DESC"
)

// Validate the order direction value.
func (o OrderDirection) Validate() error {
	if o != OrderDirectionAsc && o != OrderDirectionDesc {
		return fmt.Errorf("%s is not a valid OrderDirection", o)
	}
	return nil
}

// String implements fmt.Stringer interface.
func (o OrderDirection) String() string {
	return string(o)
}

// MarshalGQL implements graphql.Marshaler interface.
func (o OrderDirection) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(o.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (o *OrderDirection) UnmarshalGQL(val interface{}) error {
	str, ok := val.(string)
	if !ok {
		return fmt.Errorf("order direction %T must be a string", val)
	}
	*o = OrderDirection(str)
	return o.Validate()
}

func (o OrderDirection) reverse() OrderDirection {
	if o == OrderDirectionDesc {
		return OrderDirectionAsc
	}
	return OrderDirectionDesc
}

func (o OrderDirection) orderFunc(field string) OrderFunc {
	if o == OrderDirectionDesc {
		return Desc(field)
	}
	return Asc(field)
}

func cursorsToPredicates(direction OrderDirection, after, before *Cursor, field, idField string) []func(s *sql.Selector) {
	var predicates []func(s *sql.Selector)
	if after != nil {
		if after.Value != nil {
			var predicate func([]string, ...interface{}) *sql.Predicate
			if direction == OrderDirectionAsc {
				predicate = sql.CompositeGT
			} else {
				predicate = sql.CompositeLT
			}
			predicates = append(predicates, func(s *sql.Selector) {
				s.Where(predicate(
					s.Columns(field, idField),
					after.Value, after.ID,
				))
			})
		} else {
			var predicate func(string, interface{}) *sql.Predicate
			if direction == OrderDirectionAsc {
				predicate = sql.GT
			} else {
				predicate = sql.LT
			}
			predicates = append(predicates, func(s *sql.Selector) {
				s.Where(predicate(
					s.C(idField),
					after.ID,
				))
			})
		}
	}
	if before != nil {
		if before.Value != nil {
			var predicate func([]string, ...interface{}) *sql.Predicate
			if direction == OrderDirectionAsc {
				predicate = sql.CompositeLT
			} else {
				predicate = sql.CompositeGT
			}
			predicates = append(predicates, func(s *sql.Selector) {
				s.Where(predicate(
					s.Columns(field, idField),
					before.Value, before.ID,
				))
			})
		} else {
			var predicate func(string, interface{}) *sql.Predicate
			if direction == OrderDirectionAsc {
				predicate = sql.LT
			} else {
				predicate = sql.GT
			}
			predicates = append(predicates, func(s *sql.Selector) {
				s.Where(predicate(
					s.C(idField),
					before.ID,
				))
			})
		}
	}
	return predicates
}

// PageInfo of a connection type.
type PageInfo struct {
	HasNextPage     bool    `json:"hasNextPage"`
	HasPreviousPage bool    `json:"hasPreviousPage"`
	StartCursor     *Cursor `json:"startCursor"`
	EndCursor       *Cursor `json:"endCursor"`
}

// Cursor of an edge type.
type Cursor struct {
	ID    int   `msgpack:"i"`
	Value Value `msgpack:"v,omitempty"`
}

// MarshalGQL implements graphql.Marshaler interface.
func (c Cursor) MarshalGQL(w io.Writer) {
	quote := []byte{'"'}
	w.Write(quote)
	defer w.Write(quote)
	wc := base64.NewEncoder(base64.RawStdEncoding, w)
	defer wc.Close()
	_ = msgpack.NewEncoder(wc).Encode(c)
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (c *Cursor) UnmarshalGQL(v interface{}) error {
	s, ok := v.(string)
	if !ok {
		return fmt.Errorf("%T is not a string", v)
	}
	if err := msgpack.NewDecoder(
		base64.NewDecoder(
			base64.RawStdEncoding,
			strings.NewReader(s),
		),
	).Decode(c); err != nil {
		return fmt.Errorf("cannot decode cursor: %w", err)
	}
	return nil
}

const errInvalidPagination = "INVALID_PAGINATION"

func validateFirstLast(first, last *int) (err *gqlerror.Error) {
	switch {
	case first != nil && last != nil:
		err = &gqlerror.Error{
			Message: "Passing both `first` and `last` to paginate a connection is not supported.",
		}
	case first != nil && *first < 0:
		err = &gqlerror.Error{
			Message: "`first` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	case last != nil && *last < 0:
		err = &gqlerror.Error{
			Message: "`last` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	}
	return err
}

func collectedField(ctx context.Context, path ...string) *graphql.CollectedField {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return nil
	}
	field := fc.Field
	oc := graphql.GetOperationContext(ctx)
walk:
	for _, name := range path {
		for _, f := range graphql.CollectFields(oc, field.Selections, nil) {
			if f.Alias == name {
				field = f
				continue walk
			}
		}
		return nil
	}
	return &field
}

func hasCollectedField(ctx context.Context, path ...string) bool {
	if graphql.GetFieldContext(ctx) == nil {
		return true
	}
	return collectedField(ctx, path...) != nil
}

const (
	edgesField      = "edges"
	nodeField       = "node"
	pageInfoField   = "pageInfo"
	totalCountField = "totalCount"
)

func paginateLimit(first, last *int) int {
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	return limit
}

// AlertEdge is the edge representation of Alert.
type AlertEdge struct {
	Node   *Alert `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// AlertConnection is the connection containing edges to Alert.
type AlertConnection struct {
	Edges      []*AlertEdge `json:"edges"`
	PageInfo   PageInfo     `json:"pageInfo"`
	TotalCount int          `json:"totalCount"`
}

func (c *AlertConnection) build(nodes []*Alert, pager *alertPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Alert
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Alert {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Alert {
			return nodes[i]
		}
	}
	c.Edges = make([]*AlertEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &AlertEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// AlertPaginateOption enables pagination customization.
type AlertPaginateOption func(*alertPager) error

// WithAlertOrder configures pagination ordering.
func WithAlertOrder(order *AlertOrder) AlertPaginateOption {
	if order == nil {
		order = DefaultAlertOrder
	}
	o := *order
	return func(pager *alertPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultAlertOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithAlertFilter configures pagination filter.
func WithAlertFilter(filter func(*AlertQuery) (*AlertQuery, error)) AlertPaginateOption {
	return func(pager *alertPager) error {
		if filter == nil {
			return errors.New("AlertQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type alertPager struct {
	order  *AlertOrder
	filter func(*AlertQuery) (*AlertQuery, error)
}

func newAlertPager(opts []AlertPaginateOption) (*alertPager, error) {
	pager := &alertPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultAlertOrder
	}
	return pager, nil
}

func (p *alertPager) applyFilter(query *AlertQuery) (*AlertQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *alertPager) toCursor(a *Alert) Cursor {
	return p.order.Field.toCursor(a)
}

func (p *alertPager) applyCursors(query *AlertQuery, after, before *Cursor) *AlertQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultAlertOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *alertPager) applyOrder(query *AlertQuery, reverse bool) *AlertQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultAlertOrder.Field {
		query = query.Order(direction.orderFunc(DefaultAlertOrder.Field.field))
	}
	return query
}

func (p *alertPager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultAlertOrder.Field {
			b.Comma().Ident(DefaultAlertOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Alert.
func (a *AlertQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...AlertPaginateOption,
) (*AlertConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newAlertPager(opts)
	if err != nil {
		return nil, err
	}
	if a, err = pager.applyFilter(a); err != nil {
		return nil, err
	}
	conn := &AlertConnection{Edges: []*AlertEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = a.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	a = pager.applyCursors(a, after, before)
	a = pager.applyOrder(a, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		a.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := a.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := a.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// AlertOrderField defines the ordering field of Alert.
type AlertOrderField struct {
	field    string
	toCursor func(*Alert) Cursor
}

// AlertOrder defines the ordering of Alert.
type AlertOrder struct {
	Direction OrderDirection   `json:"direction"`
	Field     *AlertOrderField `json:"field"`
}

// DefaultAlertOrder is the default ordering of Alert.
var DefaultAlertOrder = &AlertOrder{
	Direction: OrderDirectionAsc,
	Field: &AlertOrderField{
		field: alert.FieldID,
		toCursor: func(a *Alert) Cursor {
			return Cursor{ID: a.ID}
		},
	},
}

// ToEdge converts Alert into AlertEdge.
func (a *Alert) ToEdge(order *AlertOrder) *AlertEdge {
	if order == nil {
		order = DefaultAlertOrder
	}
	return &AlertEdge{
		Node:   a,
		Cursor: order.Field.toCursor(a),
	}
}

// CounterEdge is the edge representation of Counter.
type CounterEdge struct {
	Node   *Counter `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// CounterConnection is the connection containing edges to Counter.
type CounterConnection struct {
	Edges      []*CounterEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

func (c *CounterConnection) build(nodes []*Counter, pager *counterPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Counter
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Counter {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Counter {
			return nodes[i]
		}
	}
	c.Edges = make([]*CounterEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &CounterEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// CounterPaginateOption enables pagination customization.
type CounterPaginateOption func(*counterPager) error

// WithCounterOrder configures pagination ordering.
func WithCounterOrder(order *CounterOrder) CounterPaginateOption {
	if order == nil {
		order = DefaultCounterOrder
	}
	o := *order
	return func(pager *counterPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCounterOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCounterFilter configures pagination filter.
func WithCounterFilter(filter func(*CounterQuery) (*CounterQuery, error)) CounterPaginateOption {
	return func(pager *counterPager) error {
		if filter == nil {
			return errors.New("CounterQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type counterPager struct {
	order  *CounterOrder
	filter func(*CounterQuery) (*CounterQuery, error)
}

func newCounterPager(opts []CounterPaginateOption) (*counterPager, error) {
	pager := &counterPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCounterOrder
	}
	return pager, nil
}

func (p *counterPager) applyFilter(query *CounterQuery) (*CounterQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *counterPager) toCursor(c *Counter) Cursor {
	return p.order.Field.toCursor(c)
}

func (p *counterPager) applyCursors(query *CounterQuery, after, before *Cursor) *CounterQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultCounterOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *counterPager) applyOrder(query *CounterQuery, reverse bool) *CounterQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultCounterOrder.Field {
		query = query.Order(direction.orderFunc(DefaultCounterOrder.Field.field))
	}
	return query
}

func (p *counterPager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultCounterOrder.Field {
			b.Comma().Ident(DefaultCounterOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Counter.
func (c *CounterQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CounterPaginateOption,
) (*CounterConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCounterPager(opts)
	if err != nil {
		return nil, err
	}
	if c, err = pager.applyFilter(c); err != nil {
		return nil, err
	}
	conn := &CounterConnection{Edges: []*CounterEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	c = pager.applyCursors(c, after, before)
	c = pager.applyOrder(c, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		c.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := c.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := c.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// CounterOrderField defines the ordering field of Counter.
type CounterOrderField struct {
	field    string
	toCursor func(*Counter) Cursor
}

// CounterOrder defines the ordering of Counter.
type CounterOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *CounterOrderField `json:"field"`
}

// DefaultCounterOrder is the default ordering of Counter.
var DefaultCounterOrder = &CounterOrder{
	Direction: OrderDirectionAsc,
	Field: &CounterOrderField{
		field: counter.FieldID,
		toCursor: func(c *Counter) Cursor {
			return Cursor{ID: c.ID}
		},
	},
}

// ToEdge converts Counter into CounterEdge.
func (c *Counter) ToEdge(order *CounterOrder) *CounterEdge {
	if order == nil {
		order = DefaultCounterOrder
	}
	return &CounterEdge{
		Node:   c,
		Cursor: order.Field.toCursor(c),
	}
}

// FailureEdge is the edge representation of Failure.
type FailureEdge struct {
	Node   *Failure `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// FailureConnection is the connection containing edges to Failure.
type FailureConnection struct {
	Edges      []*FailureEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

func (c *FailureConnection) build(nodes []*Failure, pager *failurePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Failure
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Failure {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Failure {
			return nodes[i]
		}
	}
	c.Edges = make([]*FailureEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &FailureEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// FailurePaginateOption enables pagination customization.
type FailurePaginateOption func(*failurePager) error

// WithFailureOrder configures pagination ordering.
func WithFailureOrder(order *FailureOrder) FailurePaginateOption {
	if order == nil {
		order = DefaultFailureOrder
	}
	o := *order
	return func(pager *failurePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultFailureOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithFailureFilter configures pagination filter.
func WithFailureFilter(filter func(*FailureQuery) (*FailureQuery, error)) FailurePaginateOption {
	return func(pager *failurePager) error {
		if filter == nil {
			return errors.New("FailureQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type failurePager struct {
	order  *FailureOrder
	filter func(*FailureQuery) (*FailureQuery, error)
}

func newFailurePager(opts []FailurePaginateOption) (*failurePager, error) {
	pager := &failurePager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultFailureOrder
	}
	return pager, nil
}

func (p *failurePager) applyFilter(query *FailureQuery) (*FailureQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *failurePager) toCursor(f *Failure) Cursor {
	return p.order.Field.toCursor(f)
}

func (p *failurePager) applyCursors(query *FailureQuery, after, before *Cursor) *FailureQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultFailureOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *failurePager) applyOrder(query *FailureQuery, reverse bool) *FailureQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultFailureOrder.Field {
		query = query.Order(direction.orderFunc(DefaultFailureOrder.Field.field))
	}
	return query
}

func (p *failurePager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultFailureOrder.Field {
			b.Comma().Ident(DefaultFailureOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Failure.
func (f *FailureQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...FailurePaginateOption,
) (*FailureConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newFailurePager(opts)
	if err != nil {
		return nil, err
	}
	if f, err = pager.applyFilter(f); err != nil {
		return nil, err
	}
	conn := &FailureConnection{Edges: []*FailureEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = f.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	f = pager.applyCursors(f, after, before)
	f = pager.applyOrder(f, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		f.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := f.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := f.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// FailureOrderField defines the ordering field of Failure.
type FailureOrderField struct {
	field    string
	toCursor func(*Failure) Cursor
}

// FailureOrder defines the ordering of Failure.
type FailureOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *FailureOrderField `json:"field"`
}

// DefaultFailureOrder is the default ordering of Failure.
var DefaultFailureOrder = &FailureOrder{
	Direction: OrderDirectionAsc,
	Field: &FailureOrderField{
		field: failure.FieldID,
		toCursor: func(f *Failure) Cursor {
			return Cursor{ID: f.ID}
		},
	},
}

// ToEdge converts Failure into FailureEdge.
func (f *Failure) ToEdge(order *FailureOrder) *FailureEdge {
	if order == nil {
		order = DefaultFailureOrder
	}
	return &FailureEdge{
		Node:   f,
		Cursor: order.Field.toCursor(f),
	}
}

// FileEdge is the edge representation of File.
type FileEdge struct {
	Node   *File  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// FileConnection is the connection containing edges to File.
type FileConnection struct {
	Edges      []*FileEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

func (c *FileConnection) build(nodes []*File, pager *filePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *File
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *File {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *File {
			return nodes[i]
		}
	}
	c.Edges = make([]*FileEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &FileEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// FilePaginateOption enables pagination customization.
type FilePaginateOption func(*filePager) error

// WithFileOrder configures pagination ordering.
func WithFileOrder(order *FileOrder) FilePaginateOption {
	if order == nil {
		order = DefaultFileOrder
	}
	o := *order
	return func(pager *filePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultFileOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithFileFilter configures pagination filter.
func WithFileFilter(filter func(*FileQuery) (*FileQuery, error)) FilePaginateOption {
	return func(pager *filePager) error {
		if filter == nil {
			return errors.New("FileQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type filePager struct {
	order  *FileOrder
	filter func(*FileQuery) (*FileQuery, error)
}

func newFilePager(opts []FilePaginateOption) (*filePager, error) {
	pager := &filePager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultFileOrder
	}
	return pager, nil
}

func (p *filePager) applyFilter(query *FileQuery) (*FileQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *filePager) toCursor(f *File) Cursor {
	return p.order.Field.toCursor(f)
}

func (p *filePager) applyCursors(query *FileQuery, after, before *Cursor) *FileQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultFileOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *filePager) applyOrder(query *FileQuery, reverse bool) *FileQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultFileOrder.Field {
		query = query.Order(direction.orderFunc(DefaultFileOrder.Field.field))
	}
	return query
}

func (p *filePager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultFileOrder.Field {
			b.Comma().Ident(DefaultFileOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to File.
func (f *FileQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...FilePaginateOption,
) (*FileConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newFilePager(opts)
	if err != nil {
		return nil, err
	}
	if f, err = pager.applyFilter(f); err != nil {
		return nil, err
	}
	conn := &FileConnection{Edges: []*FileEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = f.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	f = pager.applyCursors(f, after, before)
	f = pager.applyOrder(f, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		f.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := f.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := f.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// FileOrderField defines the ordering field of File.
type FileOrderField struct {
	field    string
	toCursor func(*File) Cursor
}

// FileOrder defines the ordering of File.
type FileOrder struct {
	Direction OrderDirection  `json:"direction"`
	Field     *FileOrderField `json:"field"`
}

// DefaultFileOrder is the default ordering of File.
var DefaultFileOrder = &FileOrder{
	Direction: OrderDirectionAsc,
	Field: &FileOrderField{
		field: file.FieldID,
		toCursor: func(f *File) Cursor {
			return Cursor{ID: f.ID}
		},
	},
}

// ToEdge converts File into FileEdge.
func (f *File) ToEdge(order *FileOrder) *FileEdge {
	if order == nil {
		order = DefaultFileOrder
	}
	return &FileEdge{
		Node:   f,
		Cursor: order.Field.toCursor(f),
	}
}

// IncidentEdge is the edge representation of Incident.
type IncidentEdge struct {
	Node   *Incident `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// IncidentConnection is the connection containing edges to Incident.
type IncidentConnection struct {
	Edges      []*IncidentEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *IncidentConnection) build(nodes []*Incident, pager *incidentPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Incident
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Incident {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Incident {
			return nodes[i]
		}
	}
	c.Edges = make([]*IncidentEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &IncidentEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// IncidentPaginateOption enables pagination customization.
type IncidentPaginateOption func(*incidentPager) error

// WithIncidentOrder configures pagination ordering.
func WithIncidentOrder(order *IncidentOrder) IncidentPaginateOption {
	if order == nil {
		order = DefaultIncidentOrder
	}
	o := *order
	return func(pager *incidentPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultIncidentOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithIncidentFilter configures pagination filter.
func WithIncidentFilter(filter func(*IncidentQuery) (*IncidentQuery, error)) IncidentPaginateOption {
	return func(pager *incidentPager) error {
		if filter == nil {
			return errors.New("IncidentQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type incidentPager struct {
	order  *IncidentOrder
	filter func(*IncidentQuery) (*IncidentQuery, error)
}

func newIncidentPager(opts []IncidentPaginateOption) (*incidentPager, error) {
	pager := &incidentPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultIncidentOrder
	}
	return pager, nil
}

func (p *incidentPager) applyFilter(query *IncidentQuery) (*IncidentQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *incidentPager) toCursor(i *Incident) Cursor {
	return p.order.Field.toCursor(i)
}

func (p *incidentPager) applyCursors(query *IncidentQuery, after, before *Cursor) *IncidentQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultIncidentOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *incidentPager) applyOrder(query *IncidentQuery, reverse bool) *IncidentQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultIncidentOrder.Field {
		query = query.Order(direction.orderFunc(DefaultIncidentOrder.Field.field))
	}
	return query
}

func (p *incidentPager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultIncidentOrder.Field {
			b.Comma().Ident(DefaultIncidentOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Incident.
func (i *IncidentQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...IncidentPaginateOption,
) (*IncidentConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newIncidentPager(opts)
	if err != nil {
		return nil, err
	}
	if i, err = pager.applyFilter(i); err != nil {
		return nil, err
	}
	conn := &IncidentConnection{Edges: []*IncidentEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = i.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	i = pager.applyCursors(i, after, before)
	i = pager.applyOrder(i, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		i.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := i.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := i.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// IncidentOrderField defines the ordering field of Incident.
type IncidentOrderField struct {
	field    string
	toCursor func(*Incident) Cursor
}

// IncidentOrder defines the ordering of Incident.
type IncidentOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *IncidentOrderField `json:"field"`
}

// DefaultIncidentOrder is the default ordering of Incident.
var DefaultIncidentOrder = &IncidentOrder{
	Direction: OrderDirectionAsc,
	Field: &IncidentOrderField{
		field: incident.FieldID,
		toCursor: func(i *Incident) Cursor {
			return Cursor{ID: i.ID}
		},
	},
}

// ToEdge converts Incident into IncidentEdge.
func (i *Incident) ToEdge(order *IncidentOrder) *IncidentEdge {
	if order == nil {
		order = DefaultIncidentOrder
	}
	return &IncidentEdge{
		Node:   i,
		Cursor: order.Field.toCursor(i),
	}
}

// StatusEdge is the edge representation of Status.
type StatusEdge struct {
	Node   *Status `json:"node"`
	Cursor Cursor  `json:"cursor"`
}

// StatusConnection is the connection containing edges to Status.
type StatusConnection struct {
	Edges      []*StatusEdge `json:"edges"`
	PageInfo   PageInfo      `json:"pageInfo"`
	TotalCount int           `json:"totalCount"`
}

func (c *StatusConnection) build(nodes []*Status, pager *statusPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Status
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Status {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Status {
			return nodes[i]
		}
	}
	c.Edges = make([]*StatusEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &StatusEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// StatusPaginateOption enables pagination customization.
type StatusPaginateOption func(*statusPager) error

// WithStatusOrder configures pagination ordering.
func WithStatusOrder(order *StatusOrder) StatusPaginateOption {
	if order == nil {
		order = DefaultStatusOrder
	}
	o := *order
	return func(pager *statusPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultStatusOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithStatusFilter configures pagination filter.
func WithStatusFilter(filter func(*StatusQuery) (*StatusQuery, error)) StatusPaginateOption {
	return func(pager *statusPager) error {
		if filter == nil {
			return errors.New("StatusQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type statusPager struct {
	order  *StatusOrder
	filter func(*StatusQuery) (*StatusQuery, error)
}

func newStatusPager(opts []StatusPaginateOption) (*statusPager, error) {
	pager := &statusPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultStatusOrder
	}
	return pager, nil
}

func (p *statusPager) applyFilter(query *StatusQuery) (*StatusQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *statusPager) toCursor(s *Status) Cursor {
	return p.order.Field.toCursor(s)
}

func (p *statusPager) applyCursors(query *StatusQuery, after, before *Cursor) *StatusQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultStatusOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *statusPager) applyOrder(query *StatusQuery, reverse bool) *StatusQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultStatusOrder.Field {
		query = query.Order(direction.orderFunc(DefaultStatusOrder.Field.field))
	}
	return query
}

func (p *statusPager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultStatusOrder.Field {
			b.Comma().Ident(DefaultStatusOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Status.
func (s *StatusQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...StatusPaginateOption,
) (*StatusConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newStatusPager(opts)
	if err != nil {
		return nil, err
	}
	if s, err = pager.applyFilter(s); err != nil {
		return nil, err
	}
	conn := &StatusConnection{Edges: []*StatusEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = s.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	s = pager.applyCursors(s, after, before)
	s = pager.applyOrder(s, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		s.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := s.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := s.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// StatusOrderField defines the ordering field of Status.
type StatusOrderField struct {
	field    string
	toCursor func(*Status) Cursor
}

// StatusOrder defines the ordering of Status.
type StatusOrder struct {
	Direction OrderDirection    `json:"direction"`
	Field     *StatusOrderField `json:"field"`
}

// DefaultStatusOrder is the default ordering of Status.
var DefaultStatusOrder = &StatusOrder{
	Direction: OrderDirectionAsc,
	Field: &StatusOrderField{
		field: status.FieldID,
		toCursor: func(s *Status) Cursor {
			return Cursor{ID: s.ID}
		},
	},
}

// ToEdge converts Status into StatusEdge.
func (s *Status) ToEdge(order *StatusOrder) *StatusEdge {
	if order == nil {
		order = DefaultStatusOrder
	}
	return &StatusEdge{
		Node:   s,
		Cursor: order.Field.toCursor(s),
	}
}
